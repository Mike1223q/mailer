<script>

document.addEventListener('DOMContentLoaded', async () => {
    // --- SHARED FUNCTION ---
    // This function can be used on any page that includes this script.
    
    // Function to show/hide profile banner and manage background
    const toggleProfileBanner = (show) => {
        const banner = document.getElementById('complete-profile-banner');
        if (banner) {
            if (show) {
                banner.classList.remove('d-none');
                document.body.style.background = '#000';
                document.body.style.overflow = 'hidden';
            } else {
                banner.classList.add('d-none');
                document.body.style.background = '';
                document.body.style.overflow = '';
            }
        }
    };

    const showToast = (message) => {
        const toast = document.createElement('div');
        toast.className = 'toast-notification';
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('show');
        }, 100);

        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove());
        }, 3000);
    };

    // Function to calculate delivery countdown
    const getDeliveryCountdown = (deliveryTime, messageType) => {
        if (!deliveryTime) return null;
        
        const now = new Date();
        const delivery = new Date(deliveryTime);
        const timeLeft = delivery - now;
        
        if (timeLeft <= 0) return null; // Already delivered
        
        const hours = Math.floor(timeLeft / (1000 * 60 * 60));
        const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        
        if (hours > 0) {
            return `${hours} hour${hours === 1 ? '' : 's'} left`;
        } else if (minutes > 0) {
            return `${minutes} minute${minutes === 1 ? '' : 's'} left`;
        } else {
            return 'Arriving soon';
        }
    };

    // Function to show premium edit banner
    window.showPremiumEditBanner = () => {
        const banner = document.getElementById('premium-edit-banner');
        
        if (banner) {
            banner.classList.remove('d-none');
            
            // Add event listeners for banner buttons
            const cancelBtn = document.getElementById('btn-cancel-premium-edit');
            const upgradeBtn = document.getElementById('btn-upgrade-premium');
            
            const closeBanner = () => {
                banner.classList.add('d-none');
            };
            
            if (cancelBtn) cancelBtn.onclick = closeBanner;
            if (upgradeBtn) upgradeBtn.onclick = () => {
                closeBanner();
                window.location.href = '/marketplace';
            };
        }
    };

    // Function to edit message
    window.editMessage = async (messageId, messageContent, recipientId) => {
        // Check if user has premium
        try {
            const response = await fetch('/api/user/status');
            
            if (response.ok) {
                const userData = await response.json();
                
                if (!userData.premium) {
                    // Show premium edit banner
                    showPremiumEditBanner();
                    return;
                }
            }
        } catch (error) {
            console.error('Error checking premium status:', error);
            showToast('Unable to verify premium status. Please try again.');
            return;
        }
        
        // Get recipient name from the chat header
        const recipientName = document.getElementById('chat-user-name')?.textContent || 'Unknown User';
        
        // Encode the content for URL
        const encodedContent = encodeURIComponent(messageContent);
        const encodedName = encodeURIComponent(recipientName);
        
        // Redirect to writing page in edit mode
        window.location.href = `/writing?action=email&userId=${recipientId}&name=${encodedName}&edit=true&messageId=${messageId}&content=${encodedContent}`;
    };


    // --- PAGE DETECTION & LOGIC ---

    // 1. Check if we are on the PROFILE BROWSER page
    if (document.getElementById('card-container')) {
        const mainContent = document.getElementById('main-content');
        const banner = document.getElementById('complete-profile-banner');
        const cardContainer = document.getElementById('card-container');
        let currentUser;

        try {
            const userResponse = await fetch('/api/user/status');
            if (!userResponse.ok) throw new Error('Could not fetch user status');
            currentUser = await userResponse.json();
            
            // --- NEW: Populate Sidebar User Info ---
            const sidebarAvatar = document.getElementById('sidebar-avatar');
            const sidebarName = document.getElementById('sidebar-name');
            if (sidebarAvatar && sidebarName) {
                sidebarAvatar.src = currentUser.avatar || '/media/unverifiedUser.jpg';
                sidebarName.textContent = currentUser.name || 'User';
                
                // Apply premium gradient to sidebar name if user has premium
                if (currentUser.premium) {
                    sidebarName.classList.add('premium-name-gradient');
                } else {
                    sidebarName.classList.remove('premium-name-gradient');
                }
            }
            
            // --- NEW: Update notification badge ---
            try {
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating notification badge:', error);
            }


            if (currentUser.completedProfile) {
                mainContent.classList.remove('d-none');
                toggleProfileBanner(false);
                
                const navBack = document.getElementById('nav-back');
                const navNext = document.getElementById('nav-next');
                
                let profiles = [];
                let currentUserIndex = 0;
                let profileCardElement = null;
                let timeLeftForNewMatches = ''; // Variable to store the time left

                const createCardElement = () => {
                    const existingCard = cardContainer.querySelector('.profile-card');
                    if (existingCard) {
                        profileCardElement = existingCard;
                    } else {
                        profileCardElement = document.createElement('div');
                        profileCardElement.className = 'profile-card';
                        cardContainer.prepend(profileCardElement);
                    }
                };
                
                const updateCardContent = (profile) => {
                    if (!profile) return;

                    const interestsHTML = Array.isArray(profile.interests)
                        ? profile.interests.map(interest => `<span class="interest-tag">${interest}</span>`).join('')
                        : ''; 
                    
                    profileCardElement.innerHTML = `
                        <img src="${profile.avatar}" class="profile-card-image" alt="${profile.firstName}">
                        <div class="profile-card-body">
                            <div class="profile-card-bio">
                                <div class="profile-name-row">
                                    <h4 class="card-title fw-bold ${profile.isPremium ? 'premium-name-gradient' : ''}">${profile.firstName}</h4>
                                </div>
                                <p class="card-text text-white-50">${profile.bio}</p>
                            </div>
                            <div class="profile-card-interests">
                                ${interestsHTML}
                            </div>
                        </div>
                        <div class="profile-card-actions">
                            <button class="action-btn" data-user-id="${profile.id}" data-action="email">
                                <i class="fas fa-envelope"></i> E-Letter
                            </button>
                            <button class="action-btn" data-user-id="${profile.id}" data-action="letter">
                                <i class="fas fa-paper-plane"></i> Letter
                            </button>
                        </div>
                    `;
                };

                const displayNewMatchCard = () => {
                    let cardContentHTML = '';
                    if (currentUser.premium) {
                        cardContentHTML = `
                            <h4>Find New Matches</h4>
                            <p>Your next batch of profiles will be ready in <strong>${timeLeftForNewMatches}</strong>.</p>
                            <button id="purchase-matches-btn">
                                <i class="fas fa-coins"></i> 50 Coins to Get One Now
                            </button>
                        `;
                    } else {
                        cardContentHTML = `
                            <h4>Out of Matches</h4>
                            <p>Your next free batch arrives in <strong>${timeLeftForNewMatches}</strong>. Get 70+ new matches every week with Premium, or get a new one now.</p>
                            <button id="purchase-matches-btn">
                                <i class="fas fa-coins"></i> 50 Coins
                            </button>
                            <a href="/subscribe" class="btn-premium-offer">Go Premium</a>
                        `;
                    }

                    cardContainer.innerHTML = `
                        <div class="profile-card new-match-card">
                            <div class="new-match-content">
                                <i class="fas fa-gift new-match-icon"></i>
                                ${cardContentHTML}
                            </div>
                        </div>
                    `;
                    cardContainer.append(navBack, navNext);
                    navBack.classList.remove('d-none');
                    navNext.classList.add('d-none');
                    document.getElementById('purchase-matches-btn').addEventListener('click', purchaseNewMatches);
                };

                const purchaseNewMatches = async (e) => {
                    const button = e.target.closest('button');
                    button.disabled = true;
                    button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Purchasing...';

                    try {
                        const response = await fetch('/api/purchase-matches', { method: 'POST' });
                        const data = await response.json();

                        if (response.ok) {
                            showToast('Success! Finding new matches for you.');
                            currentUserIndex = 0;
                            fetchProfiles();
                        } else {
                            showToast(data.error || 'Purchase failed.');
                            button.disabled = false;
                            button.innerHTML = '<i class="fas fa-coins"></i> 50 Coins';
                        }
                    } catch (error) {
                        showToast('An error occurred. Please try again.');
                        button.disabled = false;
                        button.innerHTML = '<i class="fas fa-coins"></i> 50 Coins';
                    }
                };

                const updateNavControls = () => {
                    // Hide the back button if we are on the first profile
                    if (currentUserIndex === 0) {
                        navBack.classList.add('d-none');
                    } else {
                        navBack.classList.remove('d-none');
                    }
                };

                const displayProfile = (index) => {
                    if (index >= profiles.length) {
                        displayNewMatchCard();
                        return;
                    }
                    
                    if (!profileCardElement || !cardContainer.contains(profileCardElement)) {
                         cardContainer.innerHTML = '';
                         createCardElement();
                         cardContainer.append(navBack, navNext);
                    }
                    
                    navBack.classList.remove('d-none');
                    navNext.classList.remove('d-none');
                    
                    profileCardElement.classList.add('changing');

                    setTimeout(() => {
                        const profile = profiles[index];
                        updateCardContent(profile);
                        profileCardElement.classList.remove('changing');
                    }, 200);

                    updateNavControls();
                };

                const fetchProfiles = async () => {
                    cardContainer.innerHTML = `<h5 class="text-center text-white-50">Loading profiles...</h5>`;

                    try {
                        const profilesResponse = await fetch('/api/profiles');
                        if (!profilesResponse.ok) throw new Error('Could not fetch profiles');
                        
                        const data = await profilesResponse.json();
                        profiles = data.profiles || data; // Handle both new and old format
                        timeLeftForNewMatches = data.timeLeft || 'Ready now';
                        
                        cardContainer.innerHTML = ''; 
                        
                        if (profiles && profiles.length > 0) {
                            createCardElement();
                            cardContainer.append(navBack, navNext);
                            navBack.classList.remove('d-none');
                            navNext.classList.remove('d-none');
                            updateCardContent(profiles[currentUserIndex]);
                            updateNavControls(); // Call here for the initial state
                        } else {
                            displayNewMatchCard();
                        }

                    } catch (error) {
                        console.error('Error fetching profiles:', error);
                        cardContainer.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
                    }
                };
                
                navNext.addEventListener('click', () => {
                    currentUserIndex++;
                    displayProfile(currentUserIndex);
                });

                navBack.addEventListener('click', () => {
                    if (currentUserIndex > 0) {
                        currentUserIndex--;
                        displayProfile(currentUserIndex);
                    }
                });
                
                cardContainer.addEventListener('click', (e) => {
                    const button = e.target.closest('.action-btn');
                    if (!button) return;
                    
                    const userId = button.dataset.userId;
                    const action = button.dataset.action;

                    if (action === 'email') {
                        const recipientName = profiles[currentUserIndex].firstName;
                        window.location.href = `/writing?action=email&name=${encodeURIComponent(recipientName)}&userId=${profiles[currentUserIndex].id}`;
                        return;
                    }

                    if (action === 'letter') {
                        const recipientName = profiles[currentUserIndex].firstName;
                        window.location.href = `/writing?action=letter&name=${encodeURIComponent(recipientName)}&userId=${profiles[currentUserIndex].id}`;
                        return;
                    }
                });

                fetchProfiles();

            } else {
                mainContent.classList.add('d-none');
                toggleProfileBanner(true);
            }
        } catch (error) {
            console.error('Initialization Error:', error);
            mainContent.innerHTML = `<div class="alert alert-danger">Error loading page: ${error.message}</div>`;
            toggleProfileBanner(false);
        }
    }


    // 2. Check if we are on the LETTER WRITING page
    if (document.getElementById('letter-body')) {
        let currentUser;
        let isSaved = false;
        let originalContent = '';
        
        const letterBody = document.getElementById('letter-body');
        const suggestions = document.querySelectorAll('.suggestion-btn');
        const cancelButton = document.querySelector('.btn-cancel');
        const sendButton = document.querySelector('.btn-send');
        const saveButton = document.querySelector('.btn-save');
        const safesendToggle = document.getElementById('safesend-toggle');
        

        // Load SafeSend preferences
        const loadSafeSendPreferences = async () => {
            try {
                const response = await fetch('/api/safesend-preferences');
                if (response.ok) {
                    const data = await response.json();
                    safesendToggle.checked = data.safesendEnabled;
                }
            } catch (error) {
                console.error('Error loading SafeSend preferences:', error);
            }
        };

        // Update SafeSend preferences
        const updateSafeSendPreferences = async (enabled) => {
            try {
                const response = await fetch('/api/update-safesend', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showToast(`SafeSend ${enabled ? 'enabled' : 'disabled'} successfully`);
                } else {
                    const errorData = await response.json();
                    showToast(errorData.error || 'Failed to update SafeSend preferences');
                    // Revert toggle if update failed
                    safesendToggle.checked = !enabled;
                }
            } catch (error) {
                console.error('Error updating SafeSend preferences:', error);
                showToast('Failed to update SafeSend preferences');
                // Revert toggle if update failed
                safesendToggle.checked = !enabled;
            }
        };

        // Load SafeSend preferences when page loads
        loadSafeSendPreferences();

        // Handle SafeSend toggle changes
        safesendToggle.addEventListener('change', (e) => {
            updateSafeSendPreferences(e.target.checked);
        });

        // Show SafeSend status indicator
        const showSafeSendStatus = (enabled) => {
            const description = document.querySelector('.safesend-description small');
            if (enabled) {
                description.innerHTML = 'Content safety filter enabled. <span style="color: var(--glow-color-1);">‚úì Your messages will be filtered for safety.</span>';
            } else {
                description.innerHTML = 'Content safety filter disabled for you. <span style="color: var(--subtle-font-color);">‚ö† Other users can still enforce SafeSend on messages sent to them.</span>';
            }
        };

        // Update status display when preferences change
        safesendToggle.addEventListener('change', (e) => {
            showSafeSendStatus(e.target.checked);
        });

        // Show initial status
        showSafeSendStatus(safesendToggle.checked);

        const urlParams = new URLSearchParams(window.location.search);
        const recipientName = urlParams.get('name') || 'User';
        const action = urlParams.get('action') || 'letter'; // Default to letter if not specified
        const recipientId = urlParams.get('userId');
        const isEditMode = urlParams.get('edit') === 'true';
        const messageId = urlParams.get('messageId');
        const editContent = urlParams.get('content');
        document.getElementById('recipient-name').textContent = recipientName;

        // Handle edit mode
        if (isEditMode && editContent) {
            letterBody.value = decodeURIComponent(editContent);
            originalContent = letterBody.value;
            
            // Update page title and button text for edit mode
            document.querySelector('h2').textContent = 'Edit E-Letter';
            sendButton.innerHTML = 'Update E-Letter <i class="fas fa-save"></i>';
            sendButton.textContent = 'Update E-Letter';
            
            // Hide delivery confirmation banner in edit mode
            const eletterBanner = document.getElementById('eletter-confirmation-banner');
            if (eletterBanner) {
                eletterBanner.classList.add('d-none');
            }
        }

        // Function to load draft
        const loadDraft = async () => {
            if (!recipientId) return;
            
            try {
                const response = await fetch(`/api/load-draft?recipientId=${recipientId}&action=${action}`);
                
                if (response.ok) {
                    const draftData = await response.json();
                    letterBody.value = draftData.content;
                    originalContent = draftData.content;
                    isSaved = true;
                    
                    // Update save button to show saved state
                    saveButton.textContent = 'Saved ';
                    saveButton.innerHTML = 'Saved <i class="fas fa-check"></i>';
                    saveButton.classList.add('saved');
                    
                    // Show notification about loaded draft
                    showToast(`Draft loaded from ${new Date(draftData.updatedAt).toLocaleDateString()}`);
                }
            } catch (error) {
                console.error('Error loading draft:', error);
                // Don't show error toast for draft loading - it's optional
            }
        };

        // Load draft when page loads
        loadDraft();

        // Update send button text based on action type (skip if in edit mode)
        const sendBtn = document.getElementById('send-btn');
        if (sendBtn && !isEditMode) {
            if (action === 'email') {
                sendBtn.textContent = 'Send E-Letter ';
                sendBtn.innerHTML = 'Send E-Letter <i class="fas fa-envelope"></i>';
            } else {
                sendBtn.textContent = 'Send Letter ';
                sendBtn.innerHTML = 'Send Letter <i class="fas fa-paper-plane"></i>';
            }
        }

        // Update sidebar with user information
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    const sidebarPremiumBadge = document.getElementById('sidebar-premium-badge');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || '/media/unverifiedUser.jpg';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                    if (sidebarPremiumBadge) {
                        if (userData.premium) {
                            sidebarPremiumBadge.classList.remove('d-none');
                        } else {
                            sidebarPremiumBadge.classList.add('d-none');
                        }
                    }
                }
                
                // Update notification badge
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Update sidebar when page loads
        updateSidebar();

        // Check if profile is complete for writing page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on writing page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }

        // Function to check if content has changed
        const checkContentChange = () => {
            if (isSaved && letterBody.value !== originalContent) {
                isSaved = false;
                saveButton.textContent = 'Save ';
                saveButton.innerHTML = 'Save <i class="fas fa-save"></i>';
                saveButton.classList.remove('saved');
            }
        };

        // Listen for text changes
        letterBody.addEventListener('input', checkContentChange);
        letterBody.addEventListener('paste', checkContentChange);
        letterBody.addEventListener('keydown', checkContentChange);

        suggestions.forEach(button => {
            button.addEventListener('click', () => {
                const suggestionText = button.textContent;
                if (letterBody.value.trim() === '') {
                    letterBody.value = suggestionText;
                } else {
                    letterBody.value += ` ${suggestionText}`;
                }
                letterBody.focus();
                checkContentChange(); // Check for changes after adding suggestion
            });
        });

        cancelButton.addEventListener('click', (e) => {
            e.preventDefault();
            window.history.back();
        });

        // Save button functionality
        saveButton.addEventListener('click', async () => {
            if (letterBody.value.trim() === '') {
                showToast('Cannot save empty content.');
                return;
            }

            try {
                saveButton.disabled = true;
                saveButton.textContent = 'Saving...';
                
                const saveData = {
                    content: letterBody.value,
                    recipientId: urlParams.get('userId'),
                    recipientName: recipientName,
                    action: action
                };

                const response = await fetch('/api/save-draft', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(saveData)
                });

                if (response.ok) {
                    isSaved = true;
                    originalContent = letterBody.value;
                    saveButton.textContent = 'Saved ';
                    saveButton.innerHTML = 'Saved <i class="fas fa-check"></i>';
                    saveButton.classList.add('saved');
                    showToast('Draft saved successfully!');
                } else {
                    const errorData = await response.json();
                    showToast(errorData.error || 'Failed to save draft.');
                }
            } catch (error) {
                console.error('Save error:', error);
                showToast('Failed to save draft. Please try again.');
            } finally {
                saveButton.disabled = false;
            }
        });

        try {
            const userResponse = await fetch('/api/user/status');
            if (!userResponse.ok) throw new Error('Could not fetch user status');
            currentUser = await userResponse.json();

            // Only check letter credits if the action is 'letter'
            if (action === 'letter' && !currentUser.letterCredits) {
                sendButton.style.backgroundColor = '#555';
                sendButton.style.boxShadow = 'none';
                sendButton.style.opacity = '0.7';
            }

            // Boost button will be shown in the E-Letter confirmation popup

            sendButton.addEventListener('click', async () => {
                // Only check letter credits if the action is 'letter'
                if (action === 'letter' && !currentUser.letterCredits) {
                    showToast('You do not have enough credits to send a letter.');
                    return;
                }
                
                if (letterBody.value.trim() === '') {
                    showToast('Your message cannot be empty.');
                    return;
                }

                // In edit mode, send directly without confirmation banner
                if (isEditMode) {
                    await sendMessage();
                    return;
                }

                // Show confirmation banner for E-Letters
                if (action === 'email') {
                    showELetterConfirmation();
                    return;
                }

                // Show confirmation banner for physical letters
                if (action === 'letter') {
                    showLetterConfirmation();
                    return;
                }

                // For other actions, send directly
                await sendMessage();
            });

            // Boost button event listener is now added when E-Letter popup is shown

            // Function to show E-Letter confirmation banner
            const showELetterConfirmation = () => {
                const banner = document.getElementById('eletter-confirmation-banner');
                banner.classList.remove('d-none');
                
                // Update boost button text based on current boost count
                const boostButton = document.getElementById('boost-delivery-btn');
                if (boostButton) {
                    if (currentUser.boosts > 0) {
                        boostButton.textContent = `Boost Delivery (1h) - ${currentUser.boosts} left`;
                        boostButton.style.opacity = '1';
                    } else {
                        boostButton.textContent = 'Boost Delivery (1h) - No boosts';
                        boostButton.style.opacity = '0.6';
                    }
                    
                    // Add boost button event listener
                    boostButton.onclick = async () => {
                        if (letterBody.value.trim() === '') {
                            showToast('Your message cannot be empty.');
                            return;
                        }

                        // Check if user has boosts
                        if (currentUser.boosts <= 0) {
                            showBoostDeliveryBanner();
                            return;
                        }

                        // Show boost confirmation
                        showBoostConfirmation();
                    };
                }
                
                // Add event listeners for banner buttons
                const cancelBtn = document.getElementById('btn-cancel-eletter');
                const confirmBtn = document.getElementById('btn-confirm-eletter');
                
                const closeBanner = () => {
                    banner.classList.add('d-none');
                };
                
                cancelBtn.onclick = closeBanner;
                confirmBtn.onclick = async () => {
                    closeBanner();
                    await sendMessage();
                };
            };

            // Function to show physical letter confirmation banner
            const showLetterConfirmation = () => {
                const banner = document.getElementById('letter-confirmation-banner');
                banner.classList.remove('d-none');
                
                // Add event listeners for banner buttons
                const cancelBtn = document.getElementById('btn-cancel-letter-confirm');
                const confirmBtn = document.getElementById('btn-confirm-letter');
                const closeBtn = document.getElementById('btn-cancel-letter');
                
                const closeBanner = () => {
                    banner.classList.add('d-none');
                };
                
                cancelBtn.onclick = closeBanner;
                closeBtn.onclick = closeBanner;
                confirmBtn.onclick = async () => {
                    closeBanner();
                    await sendMessage();
                };
            };

            // Function to show boost confirmation
            const showBoostConfirmation = () => {
                const confirmed = confirm(`Use 1 boost to deliver this E-Letter in 1 hour instead of 24 hours?\n\nYou have ${currentUser.boosts} boosts remaining.`);
                if (confirmed) {
                    sendMessageWithBoost();
                }
            };

            // Function to show boost delivery banner (no boosts)
            const showBoostDeliveryBanner = () => {
                const banner = document.getElementById('boost-delivery-banner');
                banner.classList.remove('d-none');
                
                // Add event listeners for banner buttons
                const cancelBtn = document.getElementById('btn-cancel-boost');
                const buyBtn = document.getElementById('btn-buy-boosts');
                
                const closeBanner = () => {
                    banner.classList.add('d-none');
                };
                
                cancelBtn.onclick = closeBanner;
                buyBtn.onclick = () => {
                    closeBanner();
                    window.location.href = '/marketplace';
                };
            };


            // Function to send message with boost
            const sendMessageWithBoost = async () => {
                try {
                    const boostButton = document.getElementById('boost-delivery-btn');
                    if (boostButton) {
                        boostButton.disabled = true;
                        boostButton.textContent = 'Sending with Boost...';
                    }
                    
                    const sendData = {
                        content: letterBody.value,
                        recipientId: recipientId,
                        messageType: action,
                        useBoost: true
                    };

                    const response = await fetch('/api/send-message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(sendData)
                    });

                    const data = await response.json();

                    if (response.ok) {
                        showToast('E-Letter sent with boost! Will be delivered in 1 hour! ‚ö°');
                        
                        // Update user's boost count
                        currentUser.boosts = currentUser.boosts - 1;
                        if (currentUser.boosts > 0) {
                            boostButton.textContent = `Boost Delivery (1h) - ${currentUser.boosts} left`;
                        } else {
                            boostButton.style.display = 'none';
                        }
                        
                        // Redirect to chats page
                        setTimeout(() => {
                            window.location.href = `/chats?id=${recipientId}`;
                        }, 1500);
                    } else {
                        if (data.safesendBlocked) {
                            showToast('SafeSend blocked your message due to inappropriate content. Even if you disabled SafeSend, the recipient has it enabled, so all messages sent to them are filtered for safety.');
                        } else {
                            showToast(data.error || 'Failed to send message.');
                        }
                    }
                } catch (error) {
                    console.error('Send with boost error:', error);
                    showToast('Failed to send message. Please try again.');
                } finally {
                    const boostButton = document.getElementById('boost-delivery-btn');
                    if (boostButton) {
                        boostButton.disabled = false;
                        if (currentUser.boosts > 0) {
                            boostButton.textContent = `Boost Delivery (1h) - ${currentUser.boosts} left`;
                        }
                    }
                }
            };

            // Function to actually send the message
            const sendMessage = async () => {
                try {
                    sendButton.disabled = true;
                    sendButton.textContent = isEditMode ? 'Updating...' : 'Sending...';
                    
                    if (isEditMode) {
                        // Handle edit mode
                        const editData = {
                            messageId: messageId,
                            content: letterBody.value
                        };

                        const response = await fetch('/api/edit-message', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(editData)
                        });

                        const data = await response.json();

                        if (response.ok) {
                            showToast('E-Letter updated successfully!');
                            
                            // Redirect back to chat
                            setTimeout(() => {
                                window.location.href = `/chat-view?id=${recipientId}`;
                            }, 1500);
                        } else {
                            if (data.safesendBlocked) {
                                showToast('SafeSend blocked your message due to inappropriate content. Even if you disabled SafeSend, the recipient has it enabled, so all messages sent to them are filtered for safety.');
                            } else {
                                showToast(data.error || 'Failed to update message.');
                            }
                        }
                    } else {
                        // Handle new message
                        const sendData = {
                            content: letterBody.value,
                            recipientId: recipientId,
                            messageType: action
                        };

                        const response = await fetch('/api/send-message', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(sendData)
                        });

                        const data = await response.json();

                        if (response.ok) {
                            const messageType = action === 'email' ? 'E-Letter' : 'Letter';
                            showToast(`${messageType} sent successfully!`);
                            
                            // Redirect to chats page
                            setTimeout(() => {
                                window.location.href = `/chats?id=${recipientId}`;
                            }, 1500);
                        } else {
                            if (response.status === 402) {
                                showToast('Insufficient letter credits. Please purchase more credits.');
                            } else if (data.safesendBlocked) {
                                showToast('SafeSend blocked your message due to inappropriate content. Even if you disabled SafeSend, the recipient has it enabled, so all messages sent to them are filtered for safety.');
                            } else {
                                showToast(data.error || 'Failed to send message.');
                            }
                        }
                    }
                } catch (error) {
                    console.error('Send error:', error);
                    showToast(isEditMode ? 'Failed to update message. Please try again.' : 'Failed to send message. Please try again.');
                } finally {
                    sendButton.disabled = false;
                    if (isEditMode) {
                        sendButton.textContent = 'Update E-Letter';
                        sendButton.innerHTML = 'Update E-Letter <i class="fas fa-save"></i>';
                    } else {
                        sendButton.textContent = action === 'email' ? 'Send E-Letter' : 'Send Letter';
                        sendButton.innerHTML = action === 'email' ? 'Send E-Letter <i class="fas fa-envelope"></i>' : 'Send Letter <i class="fas fa-paper-plane"></i>';
                    }
                }
            };


        } catch (error) {
            console.error('Initialization Error:', error);
            sendButton.disabled = true;
            sendButton.style.opacity = '0.5';
            sendButton.style.cursor = 'not-allowed';
            showToast('Could not verify credits. Sending is disabled.');
        }
    }

    // 3. Check if we are on the CHATS page
    if (document.getElementById('chats-list')) {
        let allChats = [];
        let filteredChats = [];
        
        const chatsList = document.getElementById('chats-list');
        const noChats = document.getElementById('no-chats');
        const searchInput = document.getElementById('search-chats');

        // Function to format timestamp
        const formatTime = (timestamp) => {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else if (diffDays === 1) {
                return 'Yesterday';
            } else if (diffDays < 7) {
                return date.toLocaleDateString([], { weekday: 'short' });
            } else {
                return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            }
        };

        // Function to truncate message
        const truncateMessage = (message, maxLength = 60) => {
            // Remove HTML tags and markdown formatting for preview
            let cleanMessage = message
                .replace(/<[^>]*>/g, '') // Remove HTML tags
                .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold formatting
                .replace(/\*(.*?)\*/g, '$1') // Remove italic formatting
                .replace(/\n/g, ' '); // Replace newlines with spaces
            
            // Special handling for delivery messages
            if (cleanMessage.includes('will be delivered in') || cleanMessage.includes('will be shipped within')) {
                cleanMessage = cleanMessage.replace(/will be delivered in \d+ hours!.*/, 'will be delivered soon...');
                cleanMessage = cleanMessage.replace(/will be shipped within.*/, 'will be shipped soon...');
            }
            
            if (cleanMessage.length <= maxLength) return cleanMessage;
            return cleanMessage.substring(0, maxLength) + '...';
        };

        // Function to create chat item HTML
        const createChatItem = (chat, unreadCounts = {}) => {
            const lastMessage = chat.messages[chat.messages.length - 1];
            // Get current user ID from the page or use a fallback
            const currentUserId = window.currentUserId || null;
            const isOutgoing = currentUserId && lastMessage.senderId == currentUserId;
            const unreadCount = unreadCounts[chat.userId] ? unreadCounts[chat.userId].total : 0;
            
            // Get delivery countdown for outgoing e-letters only (not regular letters)
            const countdown = isOutgoing && lastMessage.messageType === 'email' 
                ? getDeliveryCountdown(lastMessage.deliveryTime, lastMessage.messageType) 
                : null;
            
            // Format message content based on type
            let displayContent = lastMessage.content;
            if (lastMessage.messageType === 'gift') {
                try {
                    const giftData = JSON.parse(lastMessage.content);
                    displayContent = `üéÅ Gift sent: ${giftData.amount} coins${giftData.message ? ` - "${giftData.message}"` : ''}`;
                } catch (e) {
                    displayContent = `üéÅ Gift sent: ${lastMessage.content} coins`;
                }
            }
            
            return `
                <div class="chat-item ${unreadCount > 0 ? 'has-unread' : ''}" data-user-id="${chat.userId}">
                    <div class="chat-item-header">
                        <img src="${chat.avatar || '/media/unverifiedUser.jpg'}" 
                             alt="${chat.name}" class="chat-avatar">
                        <div class="chat-info">
                            <div class="chat-name">${chat.name}</div>
                            <div class="chat-last-message">
                                ${isOutgoing ? 'You: ' : ''}${truncateMessage(displayContent)}
                            </div>
                        </div>
                        <div class="chat-meta">
                            <div class="chat-time">${formatTime(lastMessage.timestamp)}</div>
                            <div class="chat-badges">
                                ${countdown ? `<div class="chat-countdown">${countdown}</div>` : ''}
                                <div class="chat-type-badge badge-${lastMessage.messageType}">
                                    ${lastMessage.messageType === 'email' ? 'E-Letter' : lastMessage.messageType === 'gift' ? 'Gift' : lastMessage.messageType}
                                </div>
                                ${unreadCount > 0 ? `<div class="chat-unread-badge">${unreadCount}</div>` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        };

        // Function to render chats
        const renderChats = async (chats) => {
            if (chats.length === 0) {
                chatsList.style.display = 'none';
                noChats.style.display = 'block';
                return;
            }

            chatsList.style.display = 'block';
            noChats.style.display = 'none';
            
            // Fetch unread counts
            let unreadCounts = {};
            try {
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    unreadCounts = unreadData.unreadBySender || {};
                }
            } catch (error) {
                console.error('Error fetching unread counts:', error);
            }
            
            chatsList.innerHTML = chats.map(chat => createChatItem(chat, unreadCounts)).join('');
            
            // Add click handlers
            document.querySelectorAll('.chat-item').forEach(item => {
                item.addEventListener('click', async () => {
                    const userId = item.dataset.userId;
                    
                    // Navigate to chat view without marking as read
                    // Messages will be marked as read when actually viewed in chat-view
                    window.location.href = `/chat-view?id=${userId}`;
                });
            });
            
            // Start countdown updates for chat list
            startChatListCountdownUpdates(chats);
        };

        // Function to update countdown timers in chat list
        const updateChatListCountdowns = (chats) => {
            const countdownElements = document.querySelectorAll('.chat-countdown');
            let hasActiveCountdowns = false;
            
            countdownElements.forEach((element, index) => {
                const chatItem = element.closest('.chat-item');
                const userId = chatItem.dataset.userId;
                const chat = chats.find(c => c.userId == userId);
                
                if (chat && chat.messages.length > 0) {
                    const lastMessage = chat.messages[chat.messages.length - 1];
                    const currentUserId = window.currentUserId || null;
                    const isOutgoing = currentUserId && lastMessage.senderId == currentUserId;
                    
                    if (isOutgoing && lastMessage.messageType === 'email') {
                        const countdown = getDeliveryCountdown(lastMessage.deliveryTime, lastMessage.messageType);
                        if (countdown) {
                            element.textContent = countdown;
                            hasActiveCountdowns = true;
                        } else {
                            element.remove(); // Remove countdown if delivered
                        }
                    }
                }
            });
            
            return hasActiveCountdowns;
        };

        // Function to start countdown updates for chat list
        let chatListCountdownInterval;
        const startChatListCountdownUpdates = (chats) => {
            if (chatListCountdownInterval) {
                clearInterval(chatListCountdownInterval);
            }
            
            // Update every minute
            chatListCountdownInterval = setInterval(() => {
                const hasActiveCountdowns = updateChatListCountdowns(chats);
                if (!hasActiveCountdowns) {
                    clearInterval(chatListCountdownInterval);
                }
            }, 60000);
            
            // Initial update
            updateChatListCountdowns(chats);
        };

        // Function to filter chats
        const filterChats = async (searchTerm) => {
            if (!searchTerm.trim()) {
                filteredChats = allChats;
            } else {
                filteredChats = allChats.filter(chat => 
                    chat.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    chat.messages.some(msg => 
                        msg.content.toLowerCase().includes(searchTerm.toLowerCase())
                    )
                );
            }
            await renderChats(filteredChats);
        };

        // Search functionality
        searchInput.addEventListener('input', async (e) => {
            await filterChats(e.target.value);
        });

        // Refresh button functionality
        const refreshButton = document.getElementById('btn-refresh-chats');
        if (refreshButton) {
            refreshButton.addEventListener('click', () => {
                refreshButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                refreshButton.disabled = true;
                
                loadChats().finally(() => {
                    refreshButton.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    refreshButton.disabled = false;
                });
            });
        }

                // Load chats
        const loadChats = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (!userResponse.ok) throw new Error('Could not fetch user status');
                const currentUser = await userResponse.json();
                
                // Set current user ID globally for use in other functions
                window.currentUserId = currentUser.id;

                const chatHistoryResponse = await fetch('/api/chat-history');
                if (!chatHistoryResponse.ok) throw new Error('Could not fetch chat history');
                const chatHistory = await chatHistoryResponse.json();

                // Process chat history into chat list
                const chatHistoryData = chatHistory.chatHistory || {};
                const chats = [];

                for (const [userId, messages] of Object.entries(chatHistoryData)) {
                    if (messages && messages.length > 0) {
                        try {
                            // Get user info for this chat
                            const userInfoResponse = await fetch(`/api/user-info/${userId}`);
                            if (userInfoResponse.ok) {
                                const userInfo = await userInfoResponse.json();
                                chats.push({
                                    userId: userId,
                                    name: userInfo.firstName || 'Unknown User',
                                    avatar: userInfo.avatar,
                                    messages: messages
                                });
                            }
                        } catch (userError) {
                            console.error(`Error getting user info for ${userId}:`, userError);
                        }
                    }
                }

                // Sort by most recent message
                chats.sort((a, b) => {
                    const aTime = new Date(a.messages[a.messages.length - 1].timestamp);
                    const bTime = new Date(b.messages[b.messages.length - 1].timestamp);
                    return bTime - aTime;
                });

                allChats = chats;
                filteredChats = chats;
                await renderChats(chats);

            } catch (error) {
                console.error('Error loading chats:', error);
                chatsList.innerHTML = '<div class="error-message">Failed to load conversations. Please try again.</div>';
            }
        };

        // Update sidebar
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    const sidebarPremiumBadge = document.getElementById('sidebar-premium-badge');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || '/media/unverifiedUser.jpg';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                    if (sidebarPremiumBadge) {
                        if (userData.premium) {
                            sidebarPremiumBadge.classList.remove('d-none');
                        } else {
                            sidebarPremiumBadge.classList.add('d-none');
                        }
                    }
                }
                
                // Update notification badge
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Initialize
        updateSidebar();
        loadChats();

        // Check if profile is complete for chats page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on chats page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }

        // Refresh chats when page becomes visible (user navigates back)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                loadChats();
            }
        });

        // Also refresh on page focus (when user clicks back to tab)
        window.addEventListener('focus', () => {
            loadChats();
        });

        // Refresh when user navigates back to the page
        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                loadChats();
            }
        });
    }

    // 4. Check if we are on the CHAT VIEW page
    if (document.getElementById('messages-container')) {
        let currentUserId = null;
        let otherUserId = null;
        let otherUserName = '';
        let otherUserAvatar = '';
        let currentMessages = [];
        
        const messagesContainer = document.getElementById('messages-container');
        const writeEmailButton = document.getElementById('btn-write-email');
        const writeLetterButton = document.getElementById('btn-write-letter');
        const chatUserName = document.getElementById('chat-user-name');
        const chatUserAvatar = document.getElementById('chat-user-avatar');

        // Function to format timestamp
        const formatMessageTime = (timestamp) => {
            const date = new Date(timestamp);
            const now = new Date();
            const diffInHours = (now - date) / (1000 * 60 * 60);
            
            // If message is from today, show time only
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
            // If message is from yesterday, show "Yesterday" and time
            else if (diffInHours < 48 && date.toDateString() === new Date(now.getTime() - 24 * 60 * 60 * 1000).toDateString()) {
                return `Yesterday ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
            }
            // Otherwise show full month name and day, plus time
            else {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                const monthName = monthNames[date.getMonth()];
                const day = date.getDate();
                const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                return `${monthName} ${day} ${time}`;
            }
        };


        // Function to create message HTML
        const createMessageHTML = (message, isOutgoing) => {
            const messageClass = isOutgoing ? 'outgoing' : 'incoming';
            const messageTime = formatMessageTime(message.timestamp);
            
            // Get delivery countdown for outgoing e-letters only (not regular letters)
            const countdown = isOutgoing && message.messageType === 'email' 
                ? getDeliveryCountdown(message.deliveryTime, message.messageType) 
                : null;
            
            // Check if message can be edited (outgoing e-letter that hasn't been delivered yet)
            const canEdit = isOutgoing && message.messageType === 'email' && countdown;
            
            // Format message content (handle basic markdown-like formatting)
            let formattedContent = message.content;
            let isGiftMessage = false;
            
            if (message.messageType === 'gift') {
                isGiftMessage = true;
                try {
                    const giftData = JSON.parse(message.content);
                    formattedContent = `üéÅ Gift sent: ${giftData.amount} coins${giftData.message ? `\n\n"${giftData.message}"` : ''}`;
                } catch (e) {
                    formattedContent = `üéÅ Gift sent: ${message.content} coins`;
                }
            } else if (message.messageType === 'letter' || message.messageType === 'email') {
                // Convert markdown-like formatting to HTML
                formattedContent = message.content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br>');
            }
            
            return `
                <div class="message ${messageClass} ${message.messageType === 'letter' ? 'letter-message' : ''} ${message.messageType === 'email' ? 'email-message' : ''} ${isGiftMessage ? 'gift-message' : ''}">
                    <div class="message-content">
                        ${canEdit ? `<div class="message-edit-btn" onclick="editMessage(${message.id}, '${message.content.replace(/'/g, "\\'")}', '${message.recipientId}')" title="Edit message">
                            <i class="fas fa-edit"></i>
                        </div>` : ''}
                        <div class="message-text">${formattedContent}</div>
                        <div class="message-meta">
                            <span class="message-time">${messageTime}</span>
                            ${countdown ? `<span class="delivery-countdown">${countdown}</span>` : ''}
                            <span class="message-type-badge badge-${message.messageType}">${message.messageType === 'email' ? 'E-Letter' : message.messageType === 'gift' ? 'Gift' : message.messageType}</span>
                        </div>
                    </div>
                </div>
            `;
        };

        // Function to render messages
        const renderMessages = (messages) => {
            currentMessages = messages; // Store messages for countdown updates
            
            if (messages.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="no-messages">
                        <div class="no-messages-icon">
                            <i class="fas fa-comments"></i>
                        </div>
                        <h3>No messages yet</h3>
                        <p>Start the conversation by sending a message!</p>
                    </div>
                `;
                return;
            }

            const messagesHTML = messages.map(message => {
                const isOutgoing = message.senderId == currentUserId;
                return createMessageHTML(message, isOutgoing);
            }).join('');

            messagesContainer.innerHTML = messagesHTML;
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Start countdown updates
            startCountdownUpdates();
        };

        // Function to update countdown timers
        const updateCountdowns = () => {
            if (!currentMessages || currentMessages.length === 0) return;
            
            const countdownElements = document.querySelectorAll('.delivery-countdown');
            let hasActiveCountdowns = false;
            
            countdownElements.forEach((element, index) => {
                // Find the corresponding message
                const message = currentMessages.find(msg => {
                    const isOutgoing = msg.senderId == currentUserId;
                    return isOutgoing && msg.messageType === 'email';
                });
                
                if (message && message.deliveryTime) {
                    const countdown = getDeliveryCountdown(message.deliveryTime, message.messageType);
                    if (countdown) {
                        element.textContent = countdown;
                        hasActiveCountdowns = true;
                    } else {
                        element.remove(); // Remove countdown if delivered
                    }
                }
            });
            
            // Stop updating if no active countdowns
            if (!hasActiveCountdowns) {
                clearInterval(countdownInterval);
            }
        };

        // Function to start countdown updates
        let countdownInterval;
        const startCountdownUpdates = () => {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            
            // Update every minute
            countdownInterval = setInterval(updateCountdowns, 60000);
            
            // Initial update
            updateCountdowns();
        };



        // Function to load messages
        const loadMessages = async () => {
            try {
                const response = await fetch(`/api/chat-history/${otherUserId}`);
                if (response.ok) {
                    const data = await response.json();
                    renderMessages(data.conversation);
                } else {
                    messagesContainer.innerHTML = '<div class="error-message">Failed to load messages.</div>';
                }
            } catch (error) {
                console.error('Error loading messages:', error);
                messagesContainer.innerHTML = '<div class="error-message">Failed to load messages.</div>';
            }
        };

        // Function to load user info
        const loadUserInfo = async () => {
            try {
                const response = await fetch(`/api/user-info/${otherUserId}`);
                if (response.ok) {
                    const userInfo = await response.json();
                    otherUserName = userInfo.firstName || 'Unknown User';
                    otherUserAvatar = userInfo.avatar || '/media/unverifiedUser.jpg';
                    
                    // Update UI
                    chatUserName.textContent = otherUserName;
                    chatUserAvatar.src = otherUserAvatar;
                }
            } catch (error) {
                console.error('Error loading user info:', error);
            }
        };

        // Event listeners
        writeEmailButton.addEventListener('click', () => {
            const recipientName = encodeURIComponent(chatUserName.textContent);
            window.location.href = `/writing?action=email&userId=${otherUserId}&name=${recipientName}`;
        });

        writeLetterButton.addEventListener('click', () => {
            const recipientName = encodeURIComponent(chatUserName.textContent);
            window.location.href = `/writing?action=letter&userId=${otherUserId}&name=${recipientName}`;
        });

        // Gift Modal Functions (for chat interface)
        const showGiftModal = () => {
            const recipientName = document.getElementById('chat-user-name')?.textContent || 'this user';
            const modal = document.createElement('div');
            modal.className = 'gift-modal-overlay';
            modal.innerHTML = `
                <div class="gift-modal">
                    <div class="gift-modal-header">
                        <h3><i class="fas fa-gift"></i> Send Gift</h3>
                        <button class="gift-modal-close">&times;</button>
                    </div>
                    <div class="gift-modal-body">
                        <p>Send coins as a gift to <strong>${recipientName}</strong></p>
                        <div class="gift-amounts">
                            <button class="gift-amount-btn" data-amount="10">10 Coins</button>
                            <button class="gift-amount-btn" data-amount="25">25 Coins</button>
                            <button class="gift-amount-btn" data-amount="50">50 Coins</button>
                            <button class="gift-amount-btn" data-amount="100">100 Coins</button>
                        </div>
                        <div class="gift-custom">
                            <label>Custom Amount:</label>
                            <input type="text" id="custom-gift-amount" placeholder="Enter amount">
                        </div>
                    </div>
                    <div class="gift-modal-footer">
                        <button class="btn-cancel-gift">Cancel</button>
                        <button class="btn-send-gift-confirm" disabled>Send Gift</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Event listeners for gift modal
            const closeModal = () => {
                document.body.removeChild(modal);
            };
            
            modal.querySelector('.gift-modal-close').addEventListener('click', closeModal);
            modal.querySelector('.btn-cancel-gift').addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
            
            // Gift amount selection
            let selectedAmount = 0;
            const amountButtons = modal.querySelectorAll('.gift-amount-btn');
            const customInput = modal.querySelector('#custom-gift-amount');
            const sendButton = modal.querySelector('.btn-send-gift-confirm');
            
            amountButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    amountButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedAmount = parseInt(btn.dataset.amount);
                    customInput.value = '';
                    sendButton.disabled = false;
                });
            });
            
            customInput.addEventListener('input', () => {
                // Remove any non-numeric characters
                customInput.value = customInput.value.replace(/[^0-9]/g, '');
                
                amountButtons.forEach(b => b.classList.remove('selected'));
                selectedAmount = parseInt(customInput.value) || 0;
                
                sendButton.disabled = selectedAmount <= 0;
            });
            
            // Send gift
            sendButton.addEventListener('click', async () => {
                if (selectedAmount <= 0) return;
                
                await sendGift(selectedAmount);
                closeModal();
            });
        };
        
        const sendGift = async (amount) => {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const recipientId = urlParams.get('id');
                
                if (!recipientId) {
                    showToast('Recipient not found');
                    return;
                }
                
                const response = await fetch('/api/send-gift', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        recipientId: recipientId,
                        amount: amount,
                        message: ''
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showToast(`üéÅ Gift of ${amount} coins sent successfully!`);
                    // Refresh messages to show the gift
                    loadMessages();
                } else {
                    showToast(data.error || 'Failed to send gift');
                }
            } catch (error) {
                console.error('Error sending gift:', error);
                showToast('Failed to send gift. Please try again.');
            }
        };

        // Send Gift functionality
        const sendGiftButton = document.getElementById('btn-send-gift');
        if (sendGiftButton) {
            sendGiftButton.addEventListener('click', () => {
                showGiftModal();
            });
        }


        // Initialize chat view
        const initializeChatView = async () => {
            const urlParams = new URLSearchParams(window.location.search);
            otherUserId = urlParams.get('id');
            
            if (!otherUserId) {
                messagesContainer.innerHTML = '<div class="error-message">No user ID provided.</div>';
                return;
            }

            // Get current user ID
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    currentUserId = userData.id;
                }
            } catch (error) {
                console.error('Error getting current user:', error);
            }

            // Load user info and messages
            await loadUserInfo();
            await loadMessages();
            
            // Mark messages from this user as read
            try {
                await fetch(`/api/mark-as-read/${otherUserId}`, {
                    method: 'POST'
                });
            } catch (error) {
                console.error('Error marking messages as read:', error);
            }
        };

        // Update sidebar
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || '/media/unverifiedUser.jpg';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Initialize
        updateSidebar();
        initializeChatView();

        // Check if profile is complete for chat view page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on chat view page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }
    }

    // 5. Check if we are on the MARKETPLACE page
    if (document.getElementById('current-balance')) {
        let currentUser = null;

        // Load user balance and update display
        window.loadUserBalance = async () => {
            try {
                const response = await fetch('/api/user/status');
                if (response.ok) {
                    currentUser = await response.json();
                    
                    // Update coins balance
                    const balanceElement = document.getElementById('current-balance');
                    if (balanceElement) {
                        balanceElement.textContent = `${currentUser.coins || 0} Coins`;
                    }
                    
                    // Update letter credits balance
                    const letterCreditsElement = document.getElementById('current-letter-credits');
                    if (letterCreditsElement) {
                        letterCreditsElement.textContent = `${currentUser.letterCredits || 0} Letter Credits`;
                    }
                    
                    // Update boosts balance
                    const boostsElement = document.getElementById('current-boosts');
                    if (boostsElement) {
                        boostsElement.textContent = `${currentUser.boosts || 0} Boosts`;
                    }
                }
            } catch (error) {
                console.error('Error loading user balance:', error);
            }
        };

        // Watch ad functionality
        // Watch Ad button is handled by Unity Ads system below

        // Buy package functionality
        document.querySelectorAll('.btn-buy-package').forEach(button => {
            button.addEventListener('click', async () => {
                const packageType = button.dataset.package;
                const amount = parseInt(button.dataset.amount);
                const price = parseFloat(button.dataset.price);
                const isCredits = button.dataset.credits === 'true';
                
                const itemName = isCredits ? 'letter credits' : 'coins';
                const itemText = isCredits ? `${amount} letter credits` : `${amount} coins`;
                
                try {
                    // Show loading state
                    const originalText = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                    button.disabled = true;
                    
                    showToast(`üí≥ Creating secure payment session...`);
                    
                    const itemType = isCredits ? 'credits' : 'coins';
                    
                    // Create Stripe checkout session
                    const response = await fetch('/api/create-one-time-checkout', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            packageType: packageType,
                            amount: amount,
                            price: price,
                            itemType: itemType
                        })
                    });

                    const result = await response.json();
                    
                    if (result.success && result.url) {
                        showToast(`üîÑ Redirecting to secure payment...`);
                        // Redirect to Stripe checkout
                        window.location.href = result.url;
                    } else {
                        console.error('‚ùå Error creating checkout session:', result);
                        showToast('‚ùå Error creating payment session: ' + (result.error || 'Unknown error'), 'error');
                        
                        // Restore button state
                        button.innerHTML = originalText;
                        button.disabled = false;
                    }
                } catch (error) {
                    console.error('‚ùå Error initiating purchase:', error);
                    showToast('‚ùå Error starting payment process. Please try again.', 'error');
                    
                    // Restore button state
                    button.innerHTML = originalText;
                    button.disabled = false;
                }
            });
        });

        // Buy special items functionality
        document.querySelectorAll('.btn-buy-special').forEach(button => {
            button.addEventListener('click', async () => {
                const itemType = button.dataset.item;
                const amount = parseInt(button.dataset.amount);
                const price = parseFloat(button.dataset.price);
                const isCredits = button.dataset.credits === 'true';
                const isCoins = button.dataset.coins === 'true';
                
                console.log(`üõí Initiating special item purchase: ${itemType} for ${isCoins ? price + ' coins' : '$' + price}`);
                
                try {
                    // Show loading state
                    const originalText = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                    button.disabled = true;
                    
                    if (isCoins) {
                        // Purchase with coins
                        const response = await fetch('/api/purchase-with-coins', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                itemType: itemType,
                                amount: amount,
                                price: price
                            })
                        });

                        const result = await response.json();
                        
                        if (result.success) {
                            showToast(`‚úÖ Successfully purchased ${itemType}!`);
                            // Update balance display
                            if (window.loadUserBalance) {
                                window.loadUserBalance();
                            }
                            // Restore button state
                            button.innerHTML = originalText;
                            button.disabled = false;
                        } else {
                            showToast('‚ùå Purchase failed: ' + (result.error || 'Insufficient coins'), 'error');
                            button.innerHTML = originalText;
                            button.disabled = false;
                        }
                    } else {
                        // Purchase with money (for letter credits)
                        showToast(`üí≥ Creating secure payment session...`);
                        
                        const response = await fetch('/api/create-one-time-checkout', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                packageType: itemType,
                                amount: amount,
                                price: price,
                                itemType: 'credits'
                            })
                        });

                        const result = await response.json();
                        
                        if (result.success && result.url) {
                            console.log(`‚úÖ Checkout session created, redirecting to Stripe...`);
                            showToast(`üîÑ Redirecting to secure payment...`);
                            window.location.href = result.url;
                        } else {
                            console.error('‚ùå Error creating checkout session:', result);
                            showToast('‚ùå Error creating payment session: ' + (result.error || 'Unknown error'), 'error');
                            button.innerHTML = originalText;
                            button.disabled = false;
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error initiating special item purchase:', error);
                    showToast('‚ùå Error starting purchase process. Please try again.', 'error');
                    button.innerHTML = originalText;
                    button.disabled = false;
                }
            });
        });

        // Premium option selection
        const premiumOptions = document.querySelectorAll('.premium-option');
        const becomePremiumButton = document.getElementById('btn-become-premium');
        
        premiumOptions.forEach(option => {
            option.addEventListener('click', () => {
                // Remove selected class from all options
                premiumOptions.forEach(opt => opt.classList.remove('selected'));
                // Add selected class to clicked option
                option.classList.add('selected');
                
                // Update button text and data
                const plan = option.dataset.plan;
                const price = option.querySelector('.option-price').textContent;
                const period = option.querySelector('.option-period').textContent;
                
                becomePremiumButton.dataset.plan = plan;
                becomePremiumButton.innerHTML = `<i class="fas fa-crown"></i> Get Premium ${period.charAt(0).toUpperCase() + period.slice(1)}`;
            });
        });

        // Become premium functionality with Stripe integration
        if (becomePremiumButton) {
            becomePremiumButton.addEventListener('click', async () => {
                const selectedPlan = document.querySelector('.premium-option.selected');
                const plan = selectedPlan.dataset.plan;
                const price = selectedPlan.querySelector('.option-price').textContent;
                const period = selectedPlan.querySelector('.option-period').textContent;
                
                // Get Stripe price IDs from server (environment variables)
                const stripePriceIds = {
                    'monthly': '<%= process.env.STRIPE_PRICE_MONTHLY_SUB %>',
                    'half-year': '<%= process.env.STRIPE_PRICE_HALF_YEAR_SUB %>',
                    'yearly': '<%= process.env.STRIPE_PRICE_YEARLY_SUB %>'
                };
                
                const priceId = stripePriceIds[plan];
                if (!priceId) {
                    showToast('Invalid plan selected. Please try again.');
                    return;
                }
                
                becomePremiumButton.disabled = true;
                becomePremiumButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Creating checkout...';
                
                try {
                    // Create Stripe checkout session
                    const response = await fetch('/api/create-checkout-session', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            priceId: priceId,
                            planType: plan,
                            planName: `Premium ${period.charAt(0).toUpperCase() + period.slice(1)}`
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.url) {
                        // Redirect to Stripe checkout
                        window.location.href = data.url;
                    } else {
                        throw new Error(data.error || 'Failed to create checkout session');
                    }
                } catch (error) {
                    console.error('Error creating checkout session:', error);
                    showToast('Error processing upgrade. Please try again.');
                } finally {
                    becomePremiumButton.disabled = false;
                    const period = selectedPlan.querySelector('.option-period').textContent;
                    becomePremiumButton.innerHTML = `<i class="fas fa-crown"></i> Get Premium ${period.charAt(0).toUpperCase() + period.slice(1)}`;
                }
            });
        }

        // Update letter credits pricing based on premium status
        const updateLetterCreditsPricing = (isPremium) => {
            const letterCreditsPrice = document.getElementById('letter-credits-price');
            const discountBadge = document.getElementById('premium-discount-badge');
            const letterCreditsButton = document.querySelector('[data-item="letter-credits"]');
            
            if (isPremium) {
                // Show discounted price for premium users
                letterCreditsPrice.innerHTML = '<span style="text-decoration: line-through; opacity: 0.7; margin-right: 0.5rem;">$2.99</span><span style="color: #28a745; font-weight: 700;">$2.39</span>';
                discountBadge.style.display = 'block';
                // Update button data for premium price
                letterCreditsButton.dataset.price = '2.39';
                letterCreditsButton.dataset.amount = '1';
            } else {
                // Show only original price for non-premium users
                letterCreditsPrice.textContent = '$2.99';
                discountBadge.style.display = 'none';
                // Update button data for original price
                letterCreditsButton.dataset.price = '2.99';
                letterCreditsButton.dataset.amount = '1';
            }
        };

        // Check premium status and update pricing
        const checkPremiumStatus = async () => {
            try {
                const response = await fetch('/api/user/status');
                
                if (response.ok) {
                    const userData = await response.json();
                    
                    updateLetterCreditsPricing(userData.premium || false);
                    updatePremiumContent(userData.premium || false);
                    
                    // Update subscription display if user has premium and subscription data
                    if (userData.premium && userData.subscription) {
                        updateSubscriptionDisplay(userData.subscription);
                    }
                } else {
                    console.error('User status request failed:', response.status);
                }
            } catch (error) {
                console.error('‚ùå Error checking premium status:', error);
            }
        };

        // Update premium content based on status
        const updatePremiumContent = (isPremium) => {
            const nonPremiumContent = document.getElementById('non-premium-content');
            const premiumContent = document.getElementById('premium-content');
            
            if (isPremium) {
                if (nonPremiumContent) nonPremiumContent.style.display = 'none';
                if (premiumContent) premiumContent.style.display = 'block';
                loadSubscriptionDetails();
            } else {
                if (nonPremiumContent) nonPremiumContent.style.display = 'block';
                if (premiumContent) premiumContent.style.display = 'none';
            }
        };

        // Load subscription details
        const loadSubscriptionDetails = async () => {
            try {
                const response = await fetch('/api/subscription-details');
                if (response.ok) {
                    const subscription = await response.json();
                    if (subscription.premium) {
                        updateSubscriptionDisplay(subscription);
                    } else {
                        // If not premium, show non-premium content
                        updatePremiumContent(false);
                    }
                }
            } catch (error) {
                console.error('Error loading subscription details:', error);
                // On error, show non-premium content
                updatePremiumContent(false);
            }
        };

        // Update subscription display
        const updateSubscriptionDisplay = (subscription) => {
            const planType = document.getElementById('current-plan-type');
            const planDates = document.getElementById('current-plan-dates');
            
            if (planType && planDates) {
                const planNames = {
                    'monthly': 'Monthly Plan',
                    'half-year': '6-Month Plan',
                    'yearly': 'Yearly Plan'
                };
                
                let planText = planNames[subscription.type] || 'Premium Plan';
                if (subscription.cancelled) {
                    planText += ' (Cancelled)';
                }
                planType.textContent = planText;
                
                if (subscription.endDate) {
                    // Use the endDate from the backend (more accurate)
                    const nextBillingDate = new Date(subscription.endDate);
                    const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                    if (subscription.cancelled) {
                        planDates.textContent = `Access until: ${fullDate}`;
                    } else {
                        planDates.textContent = `Next billing: ${fullDate}`;
                    }
                } else if (subscription.startDate && subscription.type) {
                    // Fallback calculation if endDate is not available
                    const startDate = new Date(subscription.startDate);
                    let nextBillingDate;
                    
                    switch (subscription.type) {
                        case 'monthly':
                            nextBillingDate = new Date(startDate.getTime() + (30 * 24 * 60 * 60 * 1000));
                            break;
                        case 'half-year':
                            nextBillingDate = new Date(startDate.getTime() + (6 * 30 * 24 * 60 * 60 * 1000));
                            break;
                        case 'yearly':
                            nextBillingDate = new Date(startDate.getTime() + (365 * 24 * 60 * 60 * 1000));
                            break;
                        default:
                            nextBillingDate = startDate;
                    }
                    
                    const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                    if (subscription.cancelled) {
                        planDates.textContent = `Access until: ${fullDate}`;
                    } else {
                        planDates.textContent = `Next billing: ${fullDate}`;
                    }
                } else {
                    planDates.textContent = 'Next billing: Ongoing';
                }
            }
        };

        // Update sidebar
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || '/media/unverifiedUser.jpg';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                }
                
                // Update notification badge
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Initialize marketplace page
        updateSidebar();
        loadUserBalance();
        checkPremiumStatus();
        

        // Subscription management
        const subscriptionModal = document.getElementById('subscription-modal');
        const manageSubscriptionBtn = document.getElementById('btn-manage-subscription');
        const closeModalBtn = document.getElementById('btn-close-modal');
        const cancelSubscriptionBtn = document.getElementById('btn-cancel-subscription');
        const continueSubscriptionBtn = document.getElementById('btn-continue-subscription');

        // Open subscription management modal
        if (manageSubscriptionBtn) {
            manageSubscriptionBtn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/subscription-details');
                    if (response.ok) {
                        const subscription = await response.json();
                        if (subscription.premium) {
                            openSubscriptionModal(subscription);
                        }
                    }
                } catch (error) {
                    console.error('Error opening subscription modal:', error);
                }
            });
        }

        // Close modal
        if (closeModalBtn) {
            closeModalBtn.addEventListener('click', () => {
                subscriptionModal.style.display = 'none';
            });
        }

        // Close modal when clicking outside
        if (subscriptionModal) {
            subscriptionModal.addEventListener('click', (e) => {
                if (e.target === subscriptionModal) {
                    subscriptionModal.style.display = 'none';
                }
            });
        }

        // Open subscription modal with details
        const openSubscriptionModal = (subscription) => {
            const modalCurrentPlan = document.getElementById('modal-current-plan');
            const modalNextBilling = document.getElementById('modal-next-billing');
            const upgradeButtons = document.getElementById('upgrade-buttons');

            // Update modal content
            const planNames = {
                'monthly': 'Monthly Plan',
                'half-year': '6-Month Plan',
                'yearly': 'Yearly Plan'
            };

            let planText = planNames[subscription.type] || 'Premium Plan';
            if (subscription.cancelled) {
                planText += ' (Cancelled)';
            }
            modalCurrentPlan.textContent = planText;
            
            if (subscription.endDate) {
                // Use the endDate from the backend (more accurate)
                const nextBillingDate = new Date(subscription.endDate);
                const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                if (subscription.cancelled) {
                    modalNextBilling.textContent = `Access until: ${fullDate}`;
                } else {
                    modalNextBilling.textContent = `Next billing: ${fullDate}`;
                }
            } else if (subscription.startDate) {
                // Fallback calculation if endDate is not available
                const startDate = new Date(subscription.startDate);
                let nextBillingDate;
                
                switch (subscription.type) {
                    case 'monthly':
                        nextBillingDate = new Date(startDate.getTime() + (30 * 24 * 60 * 60 * 1000));
                        break;
                    case 'half-year':
                        nextBillingDate = new Date(startDate.getTime() + (6 * 30 * 24 * 60 * 60 * 1000));
                        break;
                    case 'yearly':
                        nextBillingDate = new Date(startDate.getTime() + (365 * 24 * 60 * 60 * 1000));
                        break;
                    default:
                        nextBillingDate = startDate;
                }
                
                const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                if (subscription.cancelled) {
                    modalNextBilling.textContent = `Access until: ${fullDate}`;
                } else {
                    modalNextBilling.textContent = `Next billing: ${fullDate}`;
                }
            } else {
                modalNextBilling.textContent = 'Ongoing';
            }

            // Generate upgrade options based on current plan (only upgrades allowed)
            upgradeButtons.innerHTML = '';
            const currentPlan = subscription.type;
            
            // Show/hide appropriate sections based on cancellation status
            const continueSection = document.getElementById('continue-section');
            const cancelSection = document.getElementById('cancel-section');
            const accessUntilDate = document.getElementById('access-until-date');
            
            if (subscription.cancelled) {
                // Show continue section, hide cancel section
                if (continueSection) continueSection.style.display = 'block';
                if (cancelSection) cancelSection.style.display = 'none';
                
                // Update access until date
                const endDate = new Date(subscription.endDate);
                const fullDate = endDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                if (accessUntilDate) accessUntilDate.textContent = fullDate;
                
                // Show message for cancelled subscriptions in upgrade section
                upgradeButtons.innerHTML = `
                    <p class="no-upgrade-message">Your subscription is cancelled. Premium features will remain active until ${fullDate}.</p>
                `;
            } else {
                // Show cancel section, hide continue section
                if (continueSection) continueSection.style.display = 'none';
                if (cancelSection) cancelSection.style.display = 'block';
                
                // Show upgrade options for active subscriptions
                if (currentPlan === 'monthly') {
                    upgradeButtons.innerHTML = `
                        <button class="upgrade-option-btn" data-plan="half-year">Upgrade to 6-Month ($29.99)</button>
                        <button class="upgrade-option-btn" data-plan="yearly">Upgrade to Yearly ($39.99)</button>
                    `;
                } else if (currentPlan === 'half-year') {
                    upgradeButtons.innerHTML = `
                        <button class="upgrade-option-btn" data-plan="yearly">Upgrade to Yearly ($39.99)</button>
                    `;
                } else if (currentPlan === 'yearly') {
                    upgradeButtons.innerHTML = `
                        <p class="no-upgrade-message">You're already on the highest plan!</p>
                    `;
                }
            }

            // Add event listeners to upgrade buttons
            document.querySelectorAll('.upgrade-option-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const newPlan = btn.dataset.plan;
                    if (confirm(`Are you sure you want to change to ${newPlan} plan?`)) {
                        try {
                            const response = await fetch('/api/upgrade-subscription', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ newPlan })
                            });

                            const data = await response.json();

                            if (response.ok && data.url) {
                                // Redirect to Stripe checkout for upgrade payment
                                window.location.href = data.url;
                            } else if (response.ok) {
                                showToast('Subscription updated successfully!');
                                subscriptionModal.style.display = 'none';
                                checkPremiumStatus(); // Refresh the display
                            } else {
                                const errorData = await response.json();
                                if (errorData.error && errorData.error.includes('Downgrades are not allowed')) {
                                    showToast('Downgrades are not allowed. You can only upgrade to a longer plan.');
                                } else {
                                    showToast('Failed to update subscription. Please try again.');
                                }
                            }
                        } catch (error) {
                            console.error('Error updating subscription:', error);
                            showToast('Error updating subscription. Please try again.');
                        }
                    }
                });
            });

            subscriptionModal.style.display = 'flex';
        };

        // Cancel subscription
        if (cancelSubscriptionBtn) {
            cancelSubscriptionBtn.addEventListener('click', async () => {
                if (confirm('Are you sure you want to cancel your premium subscription? Your premium features will remain active until the end of your current billing period.')) {
                    try {
                        const response = await fetch('/api/cancel-subscription', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const endDate = new Date(result.endDate);
                            showToast(`Subscription cancelled. Premium features will remain active until ${endDate.toLocaleDateString()}.`);
                            subscriptionModal.style.display = 'none';
                            checkPremiumStatus(); // Refresh the display
                        } else {
                            showToast('Failed to cancel subscription. Please try again.');
                        }
                    } catch (error) {
                        console.error('Error cancelling subscription:', error);
                        showToast('Error cancelling subscription. Please try again.');
                    }
                }
            });
        }

        // Continue subscription (reactivate cancelled subscription)
        if (continueSubscriptionBtn) {
            continueSubscriptionBtn.addEventListener('click', async () => {
                if (confirm('Are you sure you want to reactivate your subscription? Your billing will resume and you will continue to enjoy premium features.')) {
                    try {
                        continueSubscriptionBtn.disabled = true;
                        continueSubscriptionBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Reactivating...';
                        
                        const response = await fetch('/api/reactivate-subscription', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        });

                        const result = await response.json();
                        
                        if (response.ok) {
                            const nextBilling = result.nextBilling ? new Date(result.nextBilling).toLocaleDateString() : 'your next billing date';
                            showToast(`Subscription reactivated! Your next billing will be on ${nextBilling}.`);
                            subscriptionModal.style.display = 'none';
                            checkPremiumStatus(); // Refresh the display
                        } else {
                            showToast(result.error || 'Failed to reactivate subscription. Please try again.');
                        }
                    } catch (error) {
                        console.error('Error reactivating subscription:', error);
                        showToast('Error reactivating subscription. Please try again.');
                    } finally {
                        continueSubscriptionBtn.disabled = false;
                        continueSubscriptionBtn.innerHTML = '<i class="fas fa-play"></i> Continue Subscription';
                    }
                }
            });
        }

        // Check if profile is complete for marketplace page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on marketplace page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }
    }

    // 6. Check if we are on the REFERRALS page
    if (document.getElementById('referral-count')) {
        let referralData = null;

        // Load referral information
        const loadReferralData = async () => {
            try {
                const response = await fetch('/api/referral-info');
                if (response.ok) {
                    referralData = await response.json();
                    updateReferralDisplay();
                } else {
                    console.error('Failed to load referral data');
                    // Show error state instead of infinite loading
                    showErrorState();
                }
            } catch (error) {
                console.error('Error loading referral data:', error);
                // Show error state instead of infinite loading
                showErrorState();
            }
        };

        // Show error state when referral data fails to load
        const showErrorState = () => {
            const referredUsersList = document.getElementById('referred-users-list');
            if (referredUsersList) {
                referredUsersList.innerHTML = `
                    <div class="loading-referrals">
                        <div class="no-referrals-icon">
                            <i class="fas fa-exclamation-triangle"></i>
                        </div>
                        <h4>Unable to Load Referral Data</h4>
                        <p>Please refresh the page to try again.</p>
                        <button class="btn-share-now" onclick="window.location.reload()">
                            <i class="fas fa-refresh"></i> Refresh Page
                        </button>
                    </div>
                `;
            }
            
            // Set default values to prevent blank display
            document.getElementById('referral-count').textContent = '0';
            document.getElementById('referral-earnings').textContent = '$0.00';
            document.getElementById('monthly-referrals').textContent = '0';
            document.getElementById('referral-code').textContent = 'Unable to load';
            document.getElementById('referral-link').value = 'Unable to load referral link';
        };

        // Update referral display
        const updateReferralDisplay = () => {
            if (!referralData) return;

            // Update stats
            document.getElementById('referral-count').textContent = referralData.referralCount || 0;
            document.getElementById('referral-earnings').textContent = `$${referralData.earnings?.total?.toFixed(2) || '0.00'}`;
            
            // Calculate monthly referrals (placeholder logic)
            const currentMonth = new Date().getMonth();
            const monthlyCount = referralData.referredUsers.filter(user => {
                const joinDate = new Date(user.joinedAt);
                return joinDate.getMonth() === currentMonth;
            }).length;
            document.getElementById('monthly-referrals').textContent = monthlyCount;

            // Update referral code and link
            const referralCode = referralData.referralCode || 'Loading...';
            const baseUrl = window.location.origin;
            const referralLink = `${baseUrl}?ref=${referralCode}`;
            
            document.getElementById('referral-code').textContent = referralCode;
            document.getElementById('referral-link').value = referralLink;

            // Show referrer section if user was referred
            if (referralData.referredBy) {
                const referredBySection = document.getElementById('referred-by-section');
                referredBySection.classList.remove('d-none');
                document.getElementById('referrer-name').textContent = referralData.referredBy.name;
                document.getElementById('referrer-code').textContent = referralData.referredBy.referralCode;
            }

            // Update program info
            updateProgramDisplay();

            // Update referred users list
            updateReferredUsersList();
        };

        // Update program display
        const updateProgramDisplay = () => {
            if (!referralData?.programDetails) return;

            const programInfo = document.createElement('div');
            programInfo.className = 'current-program-info';
            programInfo.innerHTML = `
                <div class="program-info-card">
                    <div class="program-info-header">
                        <i class="fas fa-star"></i>
                        <h4>Your Current Program</h4>
                    </div>
                    <div class="program-info-details">
                        <h5>${referralData.programDetails.name}</h5>
                        <p>${referralData.programDetails.description}</p>
                        ${referralData.earnings?.pending > 0 ? `<div class="pending-earnings">Pending: $${referralData.earnings.pending.toFixed(2)}</div>` : ''}
                    </div>
                </div>
            `;

            // Insert after stats but before referral link section
            const statsGrid = document.querySelector('.stats-grid');
            if (statsGrid && !document.querySelector('.current-program-info')) {
                statsGrid.parentNode.insertBefore(programInfo, statsGrid.nextSibling);
            }
        };

        // Pagination state for referrals
        let referralCurrentPage = 1;
        let referralTotalPages = 1;
        let allReferralDetails = [];

        // Update referred users list with detailed earnings
        const updateReferredUsersList = async (page = 1, append = false) => {
            const referredUsersList = document.getElementById('referred-users-list');
            const noReferrals = document.getElementById('no-referrals');

            try {
                // Fetch detailed referral earnings with pagination
                const response = await fetch(`/api/user/referral-earnings?page=${page}&limit=5`);
                if (!response.ok) {
                    throw new Error('Failed to fetch referral earnings');
                }
                
                const earningsData = await response.json();
                
                // Update pagination state
                if (earningsData.pagination) {
                    referralCurrentPage = earningsData.pagination.page;
                    referralTotalPages = earningsData.pagination.total_pages;
                }

                if (append) {
                    // Append new data to existing
                    allReferralDetails = allReferralDetails.concat(earningsData.referral_details || []);
                } else {
                    // Replace data
                    allReferralDetails = earningsData.referral_details || [];
                }
                
                if (!allReferralDetails || allReferralDetails.length === 0) {
                    referredUsersList.style.display = 'none';
                    noReferrals.style.display = 'block';
                    return;
                }

                referredUsersList.style.display = 'block';
                noReferrals.style.display = 'none';

                const usersHTML = allReferralDetails.map(user => {
                    const joinDate = new Date(user.join_date).toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    });

                    // Create earnings breakdown
                    const earningsBreakdown = user.earnings.map(earning => {
                        const statusBadge = {
                            'pending': '<span class="status-badge pending">‚è≥ Pending</span>',
                            'approved': '<span class="status-badge approved">‚úÖ Approved</span>',
                            'paid': '<span class="status-badge paid">üí∞ Paid</span>'
                        }[earning.status] || '<span class="status-badge unknown">‚ùì Unknown</span>';

                        const earningDate = new Date(earning.date).toLocaleDateString('en-US', {
                            month: 'short',
                            day: 'numeric'
                        });

                        return `
                            <div class="earning-item">
                                <div class="earning-info">
                                    <span class="earning-amount">$${earning.amount.toFixed(2)}</span>
                                    <span class="earning-type">${earning.type}</span>
                                    <span class="earning-date">${earningDate}</span>
                                </div>
                                <div class="earning-status">${statusBadge}</div>
                            </div>
                        `;
                    }).join('');

                    return `
                        <div class="referred-user-card detailed">
                            <div class="referred-user-header">
                                <div class="referred-user-info">
                                    <div class="referred-user-name">${user.user_name || 'Anonymous'}</div>
                                    <div class="referred-user-email">${user.user_email}</div>
                                    <div class="referred-user-date">Joined ${joinDate}</div>
                                </div>
                                <div class="referred-user-summary">
                                    <div class="total-earned">$${user.total_earned.toFixed(2)}</div>
                                    <div class="earnings-breakdown">
                                        ${user.pending_amount > 0 ? `<span class="pending-amount">$${user.pending_amount.toFixed(2)} pending</span>` : ''}
                                        ${user.approved_amount > 0 ? `<span class="approved-amount">$${user.approved_amount.toFixed(2)} approved</span>` : ''}
                                        ${user.paid_amount > 0 ? `<span class="paid-amount">$${user.paid_amount.toFixed(2)} paid</span>` : ''}
                                    </div>
                                </div>
                            </div>
                            <div class="earnings-details">
                                <div class="earnings-header">
                                    <h4>üí∞ Earnings from ${user.user_name}</h4>
                                </div>
                                <div class="earnings-list">
                                    ${earningsBreakdown}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                // Add "Load More" button if there are more pages
                const loadMoreButton = referralCurrentPage < referralTotalPages ? `
                    <div class="load-more-container">
                        <button id="load-more-referrals" class="btn-load-more">
                            <i class="fas fa-plus"></i> Load More
                        </button>
                    </div>
                ` : '';

                referredUsersList.innerHTML = usersHTML + loadMoreButton;

                // Add click handler for Load More button
                const loadMoreBtn = document.getElementById('load-more-referrals');
                if (loadMoreBtn) {
                    loadMoreBtn.addEventListener('click', async () => {
                        loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
                        await updateReferredUsersList(referralCurrentPage + 1, true);
                    });
                }

                // Update summary stats
                if (earningsData.summary) {
                    const earningsElement = document.getElementById('referral-earnings');
                    if (earningsElement) {
                        earningsElement.textContent = `$${earningsData.summary.total_earnings.toFixed(2)}`;
                    }
                }

            } catch (error) {
                console.error('Error loading referral earnings:', error);
                referredUsersList.innerHTML = `
                    <div class="error-message">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Unable to load detailed earnings. Please refresh the page.</p>
                    </div>
                `;
            }
        };

        // Copy referral link to clipboard
        const copyReferralLink = async () => {
            const referralLinkInput = document.getElementById('referral-link');
            const copyBtn = document.getElementById('copy-link-btn');
            
            try {
                await navigator.clipboard.writeText(referralLinkInput.value);
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                copyBtn.style.background = 'linear-gradient(45deg, #00ff87, #00d4aa)';
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalText;
                    copyBtn.style.background = 'linear-gradient(45deg, var(--glow-color-1), var(--glow-color-2))';
                }, 2000);
            } catch (error) {
                console.error('Failed to copy link:', error);
                // Fallback for older browsers
                referralLinkInput.select();
                referralLinkInput.setSelectionRange(0, 99999);
                document.execCommand('copy');
                
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                setTimeout(() => {
                    copyBtn.innerHTML = originalText;
                }, 2000);
            }
        };

        // Share referral link
        const shareReferralLink = async () => {
            const referralLink = document.getElementById('referral-link').value;
            const shareData = {
                title: 'Join me on this amazing platform!',
                text: 'Sign up using my referral link and we both get benefits!',
                url: referralLink
            };

            if (navigator.share) {
                try {
                    await navigator.share(shareData);
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('Error sharing:', error);
                    }
                }
            } else {
                // Fallback: copy to clipboard
                await copyReferralLink();
            }
        };

        // Update sidebar
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || '/media/unverifiedUser.jpg';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                }
                
                // Update notification badge
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Event listeners
        document.getElementById('copy-link-btn').addEventListener('click', copyReferralLink);
        document.getElementById('share-link-btn').addEventListener('click', shareReferralLink);
        document.getElementById('share-now-btn').addEventListener('click', shareReferralLink);

        // Initialize
        updateSidebar();
        loadReferralData();
    }

    // 7. Check if we are on the ADMIN PANEL page
    if (document.getElementById('users-table-body')) {
        let usersData = [];
        let currentUserId = null;
        let usersCurrentPage = 1;
        let usersTotalPages = 1;

        // Load users data with pagination
        const loadUsersData = async (page = 1, limit = 5) => {
            try {
                // Show loading state
                const tbody = document.getElementById('users-table-body');
                tbody.innerHTML = `
                    <tr class="loading-row">
                        <td colspan="7">
                            <div class="loading-spinner">
                                <i class="fas fa-spinner fa-spin"></i>
                                Loading users...
                            </div>
                        </td>
                    </tr>
                `;
                
                // Get current search term
                const searchTerm = document.getElementById('user-search')?.value || '';
                
                // Build query parameters
                const params = new URLSearchParams({
                    page: page.toString(),
                    limit: limit.toString()
                });
                
                if (searchTerm.trim()) {
                    params.append('search', searchTerm.trim());
                }
                
                const response = await fetch(`/api/admin/users?${params.toString()}`);
                if (response.ok) {
                    const data = await response.json();
                    usersData = data.users || []; // Extract users array from paginated response
                    usersCurrentPage = data.pagination.page;
                    usersTotalPages = data.pagination.totalPages;
                    renderUsersTable();
                    renderUsersPagination();
                } else {
                    showUsersError();
                }
            } catch (error) {
                console.error('Error loading users:', error);
                showUsersError();
            }
        };

        // Load referrals data for management table
        let referralsData = [];
        let currentPage = 1;
        let totalPages = 1;
        
        const loadReferralsData = async (page = 1, status = 'all', suspicious = 'all') => {
            try {
                // Show loading state
                const tbody = document.getElementById('referrals-table-body');
                tbody.innerHTML = `
                    <tr class="loading-row">
                        <td colspan="10">
                            <div class="loading-spinner">
                                <i class="fas fa-spinner fa-spin"></i>
                                Loading referrals...
                            </div>
                        </td>
                    </tr>
                `;
                
                const response = await fetch(`/api/admin/referrals?page=${page}&limit=10&status=${status}`);
                if (response.ok) {
                    const data = await response.json();
                    referralsData = data.referrals || [];
                    currentPage = data.pagination.page;
                    totalPages = data.pagination.totalPages;
                    renderReferralsTable(suspicious);
                    renderPagination();
                } else {
                    showReferralsError();
                }
            } catch (error) {
                console.error('Error loading referrals:', error);
                showReferralsError();
            }
        };

        // Render users table
        const renderUsersTable = () => {
            const tbody = document.getElementById('users-table-body');

            if (!usersData || usersData.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" style="text-align: center; padding: 2rem; color: rgba(255,255,255,0.6);">
                            No users found matching your criteria
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = usersData.map(user => `
                <tr>
                    <td>${user.id}</td>
                    <td>${user.firstName} ${user.lastName}</td>
                    <td>${user.email}</td>
                    <td>${user.referralCount || 0}</td>
                    <td>
                        <span class="program-badge ${user.referralProgramType}">
                            ${getProgramDisplayName(user.referralProgramType)}
                        </span>
                    </td>
                    <td>${formatDate(user.created_at)}</td>
                    <td>
                        <button class="btn-change-program" onclick="openChangeProgramModal(${user.id}, '${user.firstName} ${user.lastName}', '${user.referralProgramType}')">
                            Change Program
                        </button>
                    </td>
                </tr>
            `).join('');
        };

        // Get program display name
        const getProgramDisplayName = (programType) => {
            switch(programType) {
                case 'standard': return 'Standard';
                case 'offer_5': return '$5 Offer';
                case 'offer_10': return '$10 Retention';
                default: return 'Standard';
            }
        };

        // Format date
        const formatDate = (dateString) => {
            if (!dateString) return 'N/A';
            return new Date(dateString).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        };

        // Show users error
        const showUsersError = () => {
            const tbody = document.getElementById('users-table-body');
            tbody.innerHTML = `
                <tr>
                    <td colspan="7" style="text-align: center; padding: 2rem; color: #ff4757;">
                        <i class="fas fa-exclamation-triangle"></i><br>
                        Error loading users. Please refresh the page.
                    </td>
                </tr>
            `;
        };

        // Make loadUsersData globally accessible for pagination buttons
        window.loadUsersDataPage = (page) => {
            loadUsersData(page);
        };

        // Render users pagination
        const renderUsersPagination = () => {
            const paginationContainer = document.getElementById('users-pagination');
            
            if (usersTotalPages <= 1) {
                paginationContainer.innerHTML = '';
                return;
            }

            let paginationHTML = '<nav><ul class="pagination">';
            
            // Previous button
            if (usersCurrentPage > 1) {
                paginationHTML += `<li class="page-item">
                    <a class="page-link" href="#" onclick="window.loadUsersDataPage(${usersCurrentPage - 1}); return false;">
                        <i class="fas fa-chevron-left"></i> Previous
                    </a>
                </li>`;
            }
            
            // Page numbers
            const startPage = Math.max(1, usersCurrentPage - 2);
            const endPage = Math.min(usersTotalPages, usersCurrentPage + 2);
            
            if (startPage > 1) {
                paginationHTML += `<li class="page-item">
                    <a class="page-link" href="#" onclick="window.loadUsersDataPage(1); return false;">1</a>
                </li>`;
                if (startPage > 2) {
                    paginationHTML += '<li class="page-item disabled"><span class="page-link">...</span></li>';
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const activeClass = i === usersCurrentPage ? 'active' : '';
                paginationHTML += `<li class="page-item ${activeClass}">
                    <a class="page-link" href="#" onclick="window.loadUsersDataPage(${i}); return false;">${i}</a>
                </li>`;
            }
            
            if (endPage < usersTotalPages) {
                if (endPage < usersTotalPages - 1) {
                    paginationHTML += '<li class="page-item disabled"><span class="page-link">...</span></li>';
                }
                paginationHTML += `<li class="page-item">
                    <a class="page-link" href="#" onclick="window.loadUsersDataPage(${usersTotalPages}); return false;">${usersTotalPages}</a>
                </li>`;
            }
            
            // Next button
            if (usersCurrentPage < usersTotalPages) {
                paginationHTML += `<li class="page-item">
                    <a class="page-link" href="#" onclick="window.loadUsersDataPage(${usersCurrentPage + 1}); return false;">
                        Next <i class="fas fa-chevron-right"></i>
                    </a>
                </li>`;
            }
            
            paginationHTML += '</ul></nav>';
            
            // Add page info
            paginationHTML += `<div class="pagination-info" style="margin-top: 10px; color: rgba(255,255,255,0.7); font-size: 0.9em;">
                Showing page ${usersCurrentPage} of ${usersTotalPages} (${((usersCurrentPage - 1) * 5 + 1)}-${Math.min(usersCurrentPage * 5, usersTotalPages * 5)} users)
            </div>`;
            
            paginationContainer.innerHTML = paginationHTML;
        };

        // Render referrals management table
        const renderReferralsTable = (suspiciousFilter = 'all') => {
            const tbody = document.getElementById('referrals-table-body');
            
            if (!referralsData || referralsData.length === 0) {
                tbody.innerHTML = `
                    <tr class="no-data-row">
                        <td colspan="10">
                            <div class="no-referrals-message">
                                <i class="fas fa-handshake"></i>
                                <h4>No Referrals Found</h4>
                                <p>No referral earnings recorded yet.</p>
                            </div>
                        </td>
                    </tr>
                `;
                return;
            }

            // Filter by suspicious status
            let filteredReferrals = referralsData;
            if (suspiciousFilter === 'suspected') {
                filteredReferrals = referralsData.filter(ref => ref.suspected);
            } else if (suspiciousFilter === 'clean') {
                filteredReferrals = referralsData.filter(ref => !ref.suspected);
            }

            tbody.innerHTML = filteredReferrals.map(referral => {
                const suspectedBadge = referral.suspected 
                    ? '<span class="badge badge-danger">‚ö†Ô∏è Yes</span>' 
                    : '<span class="badge badge-success">‚úÖ No</span>';
                
                const statusBadge = {
                    'pending': '<span class="badge badge-warning">Pending</span>',
                    'approved': '<span class="badge badge-info">Approved</span>',
                    'paid': '<span class="badge badge-success">Paid</span>'
                }[referral.status] || '<span class="badge badge-secondary">Unknown</span>';

                const actionButton = referral.status === 'pending' 
                    ? `<button class="btn btn-sm btn-primary approve-btn" data-referral-id="${referral.id}">
                         <i class="fas fa-check"></i> Approve
                       </button>`
                    : referral.status === 'approved'
                    ? `<button class="btn btn-sm btn-success mark-paid-btn" data-referral-id="${referral.id}">
                         <i class="fas fa-dollar-sign"></i> Mark as Paid
                       </button>`
                    : '<span class="text-success"><i class="fas fa-check-circle"></i> Paid</span>';

                const referrerIp = referral.referrer_ip || 'N/A';
                const referredIp = referral.referred_user_ip || 'N/A';
                const ipMatch = referral.referrer_ip && referral.referred_user_ip && referral.referrer_ip === referral.referred_user_ip;

                return `
                    <tr class="${referral.suspected ? 'table-warning' : ''}">
                        <td><strong>#${referral.id}</strong></td>
                        <td>
                            <div class="user-info">
                                <strong>${referral.referrer_name || 'Unknown'}</strong><br>
                                <small class="text-muted">${referral.referrer_email || 'No email'}</small>
                            </div>
                        </td>
                        <td>
                            <div class="user-info">
                                <strong>${referral.referred_name || 'Unknown'}</strong><br>
                                <small class="text-muted">${referral.referred_email || 'No email'}</small>
                            </div>
                        </td>
                        <td><strong>$${parseFloat(referral.amount || 0).toFixed(2)}</strong></td>
                        <td><span class="badge badge-secondary">${referral.earning_type}</span></td>
                        <td>
                            <small>
                                Referrer: <code>${referrerIp}</code><br>
                                Referred: <code>${referredIp}</code>
                                ${ipMatch ? '<br><span class="text-danger">‚ö†Ô∏è Same IP</span>' : ''}
                            </small>
                        </td>
                        <td>${suspectedBadge}</td>
                        <td>${statusBadge}</td>
                        <td><small>${new Date(referral.created_at).toLocaleDateString()}</small></td>
                        <td>${actionButton}</td>
                    </tr>
                `;
            }).join('');

            // Add click handlers for approve buttons
            document.querySelectorAll('.approve-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const referralId = e.target.closest('.approve-btn').dataset.referralId;
                    await approveReferral(referralId);
                });
            });

            // Add click handlers for mark as paid buttons
            document.querySelectorAll('.mark-paid-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const referralId = e.target.closest('.mark-paid-btn').dataset.referralId;
                    await markReferralAsPaid(referralId);
                });
            });
        };

        // Approve referral function
        const approveReferral = async (referralId) => {
            try {
                const response = await fetch(`/api/admin/approve-referral/${referralId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(result.message || 'Referral approved successfully!');
                    // Reload current page
                    const statusFilter = document.getElementById('referral-status-filter').value;
                    const suspiciousFilter = document.getElementById('suspicious-filter').value;
                    await loadReferralsData(currentPage, statusFilter, suspiciousFilter);
                } else {
                    const error = await response.json();
                    alert('Error approving referral: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error approving referral:', error);
                alert('Error approving referral. Please try again.');
            }
        };

        // Mark referral as paid function
        const markReferralAsPaid = async (referralId) => {
            try {
                // Confirm before marking as paid
                if (!confirm('Are you sure you want to mark this referral as paid? This action cannot be undone.')) {
                    return;
                }

                const response = await fetch(`/api/admin/mark-paid/${referralId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(result.message || 'Referral marked as paid successfully!');
                    // Reload current page
                    const statusFilter = document.getElementById('referral-status-filter').value;
                    const suspiciousFilter = document.getElementById('suspicious-filter').value;
                    await loadReferralsData(currentPage, statusFilter, suspiciousFilter);
                } else {
                    const error = await response.json();
                    alert('Error marking referral as paid: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error marking referral as paid:', error);
                alert('Error marking referral as paid. Please try again.');
            }
        };

        // Render pagination
        const renderPagination = () => {
            const container = document.getElementById('referrals-pagination');
            if (totalPages <= 1) {
                container.innerHTML = '';
                return;
            }

            let paginationHtml = '<nav><ul class="pagination">';
            
            // Previous button
            if (currentPage > 1) {
                paginationHtml += `<li class="page-item">
                    <a class="page-link" href="#" data-page="${currentPage - 1}">
                        <i class="fas fa-chevron-left"></i> Previous
                    </a>
                </li>`;
            }

            // Page numbers with smart ellipsis
            const startPage = Math.max(1, currentPage - 2);
            const endPage = Math.min(totalPages, currentPage + 2);
            
            // Show first page if we're not starting from it
            if (startPage > 1) {
                paginationHtml += `<li class="page-item">
                    <a class="page-link" href="#" data-page="1">1</a>
                </li>`;
                if (startPage > 2) {
                    paginationHtml += '<li class="page-item disabled"><span class="page-link">...</span></li>';
                }
            }
            
            // Show page numbers around current page
            for (let i = startPage; i <= endPage; i++) {
                paginationHtml += `<li class="page-item ${i === currentPage ? 'active' : ''}">
                    <a class="page-link" href="#" data-page="${i}">${i}</a>
                </li>`;
            }
            
            // Show last page if we're not ending with it
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    paginationHtml += '<li class="page-item disabled"><span class="page-link">...</span></li>';
                }
                paginationHtml += `<li class="page-item">
                    <a class="page-link" href="#" data-page="${totalPages}">${totalPages}</a>
                </li>`;
            }

            // Next button
            if (currentPage < totalPages) {
                paginationHtml += `<li class="page-item">
                    <a class="page-link" href="#" data-page="${currentPage + 1}">
                        Next <i class="fas fa-chevron-right"></i>
                    </a>
                </li>`;
            }

            paginationHtml += '</ul></nav>';
            
            // Add page info
            const totalReferrals = totalPages * 10; // Approximate, since we show 10 per page
            const startItem = (currentPage - 1) * 10 + 1;
            const endItem = Math.min(currentPage * 10, totalReferrals);
            paginationHtml += `<div class="pagination-info" style="margin-top: 10px; color: rgba(255,255,255,0.7); font-size: 0.9em; text-align: center;">
                Showing page ${currentPage} of ${totalPages} referrals
            </div>`;
            
            container.innerHTML = paginationHtml;

            // Add click handlers
            container.querySelectorAll('.page-link').forEach(link => {
                link.addEventListener('click', async (e) => {
                    e.preventDefault();
                    const page = parseInt(e.target.dataset.page);
                    if (page && page !== currentPage) {
                        const statusFilter = document.getElementById('referral-status-filter').value;
                        const suspiciousFilter = document.getElementById('suspicious-filter').value;
                        await loadReferralsData(page, statusFilter, suspiciousFilter);
                    }
                });
            });
        };

        // Show referrals error
        const showReferralsError = () => {
            const tbody = document.getElementById('referrals-table-body');
            tbody.innerHTML = `
                <tr class="error-row">
                    <td colspan="10">
                        <div class="error-message">
                            <i class="fas fa-exclamation-triangle"></i>
                            <h4>Error Loading Referrals</h4>
                            <p>Please refresh the page to try again.</p>
                        </div>
                    </td>
                </tr>
            `;
        };

        // Open change program modal
        window.openChangeProgramModal = (userId, userName, currentProgram) => {
            currentUserId = userId;
            document.getElementById('modal-user-name').textContent = userName;
            
            // Set current program as selected
            const radioButtons = document.querySelectorAll('input[name="programType"]');
            radioButtons.forEach(radio => {
                radio.checked = radio.value === currentProgram;
            });

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('changeProgramModal'));
            modal.show();
        };

        // Save program change
        const saveProgramChange = async () => {
            const selectedProgram = document.querySelector('input[name="programType"]:checked');
            if (!selectedProgram || !currentUserId) return;

            try {
                const response = await fetch(`/api/admin/users/${currentUserId}/referral-program`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        programType: selectedProgram.value
                    })
                });

                if (response.ok) {
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('changeProgramModal'));
                    modal.hide();
                    
                    // Reload users data
                    await loadUsersData();
                } else {
                    alert('Error updating referral program. Please try again.');
                }
            } catch (error) {
                console.error('Error saving program change:', error);
                alert('Error updating referral program. Please try again.');
            }
        };

        // Update sidebar function for admin panel
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || '/media/unverifiedUser.jpg';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.firstName || 'User';
                        // Apply premium gradient if user is premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                    
                    // Update notification badge
                    try {
                        const unreadResponse = await fetch('/api/unread-counts');
                        if (unreadResponse.ok) {
                            const unreadData = await unreadResponse.json();
                            const notificationBadge = document.getElementById('sidebar-notification-badge');
                            if (notificationBadge) {
                                if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                                    notificationBadge.textContent = unreadData.unreadByType.total;
                                    notificationBadge.classList.remove('d-none');
                                } else {
                                    notificationBadge.classList.add('d-none');
                                }
                            }
                        }
                    } catch (error) {
                        console.error('Error updating notification badge:', error);
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Event listeners for users search (reload data from server)
        let searchTimeout;
        document.getElementById('user-search').addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                loadUsersData(1); // Reset to page 1 when searching
            }, 300); // Debounce search for 300ms
        });
        
        document.getElementById('program-filter').addEventListener('change', () => {
            loadUsersData(1); // Reset to page 1 when filtering
        });
        document.getElementById('save-program-change').addEventListener('click', saveProgramChange);

        // Referrals event listeners
        document.getElementById('referral-status-filter').addEventListener('change', () => {
            const statusFilter = document.getElementById('referral-status-filter').value;
            const suspiciousFilter = document.getElementById('suspicious-filter').value;
            loadReferralsData(1, statusFilter, suspiciousFilter);
        });
        
        document.getElementById('suspicious-filter').addEventListener('change', () => {
            const statusFilter = document.getElementById('referral-status-filter').value;
            const suspiciousFilter = document.getElementById('suspicious-filter').value;
            renderReferralsTable(suspiciousFilter); // Just re-render current data
        });

        // Initialize
        updateSidebar();
        loadUsersData();
        loadReferralsData();
    }

    // Check if profile is complete
    try {
        const userResponse = await fetch('/api/user/status');
        if (userResponse.ok) {
            const userData = await userResponse.json();
            if (!userData.completedProfile) {
                toggleProfileBanner(true);
            }
        }
    } catch (error) {
        console.error('Error checking profile status:', error);
    }

    // --- UNITY ADS FUNCTIONALITY ---
    
    // Unity Ads configuration - these will be set from environment variables
    let unityGameID = '';
    let rewardedPlacementID = '';
    let isTestMode = true; // Set to false when going live
    
    // Create a mock Unity Ads SDK for testing
    const createMockUnityAds = () => {
        window.unityAds = {
            initialize: (gameId, testMode, listener) => {
                setTimeout(() => {
                    listener.onInitializationComplete();
                }, 100);
            },
            load: (placementId, listener) => {
                setTimeout(() => {
                    listener.onPlacementContentReady(placementId);
                }, 500);
            },
            show: (placementId) => {
                // Create a visual ad overlay
                const adOverlay = document.createElement('div');
                adOverlay.style.cssText = `
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100vw !important;
                    height: 100vh !important;
                    background: linear-gradient(45deg, #1a1a1a, #2d2d2d) !important;
                    z-index: 999999 !important;
                    display: flex !important;
                    flex-direction: column !important;
                    align-items: center !important;
                    justify-content: center !important;
                    color: white !important;
                    font-family: Arial, sans-serif !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    border: none !important;
                    outline: none !important;
                `;
                
                adOverlay.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 30px; text-align: center;">üì∫</div>
                    <div style="font-size: 32px; margin-bottom: 20px; font-weight: bold;">AD PLAYING</div>
                    <div style="font-size: 24px; margin-bottom: 40px; color: #ccc;">Mock Unity Ads Video</div>
                    <div style="font-size: 18px; color: #888; margin-bottom: 30px;">Please wait while the ad plays...</div>
                    <div style="margin-top: 20px; width: 300px; height: 8px; background: #333; border-radius: 4px; overflow: hidden; border: 2px solid #555;">
                        <div id="ad-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); transition: width 3s linear;"></div>
                    </div>
                    <div style="margin-top: 20px; font-size: 14px; color: #666;">This is a test ad simulation</div>
                `;
                
                document.body.appendChild(adOverlay);
                
                // Start progress bar
                setTimeout(() => {
                    const progressBar = document.getElementById('ad-progress');
                    if (progressBar) {
                        progressBar.style.width = '100%';
                    }
                }, 100);
                
                // Simulate ad completion after 3 seconds
                setTimeout(() => {
                    // Remove overlay
                    if (adOverlay && adOverlay.parentNode) {
                        adOverlay.parentNode.removeChild(adOverlay);
                    }
                    
                    // Find the listener and trigger completion
                    if (window.currentAdListener) {
                        window.currentAdListener.onPlacementContentStateChange(placementId, 'SHOW_STATE_COMPLETED');
                    }
                }, 3000);
            }
        };
    };

    // Wait for Unity Ads SDK to load or create mock
    const waitForUnityAds = () => {
        return new Promise((resolve, reject) => {
            let attempts = 0;
            const maxAttempts = 20; // 2 seconds max wait
            
            const checkUnityAds = () => {
                attempts++;
                if (typeof window.unityAds !== 'undefined') {
                    resolve();
                } else if (attempts >= maxAttempts) {
                    createMockUnityAds();
                    resolve();
                } else {
                    setTimeout(checkUnityAds, 100);
                }
            };
            
            checkUnityAds();
        });
    };

    // Initialize Unity Ads when the page loads
    const initializeUnityAds = async () => {
        try {
            // Wait for Unity Ads SDK to load
            await waitForUnityAds();
            
            // Get Unity Ads configuration from server
            const response = await fetch('/api/unity-ads-config');
            const config = await response.json();
            
            unityGameID = config.gameId;
            rewardedPlacementID = config.rewardedPlacementId;
            isTestMode = config.testMode;
            
            if (!unityGameID || !rewardedPlacementID) {
                return;
            }
            
            // Initialize Unity Ads
            const sdkListener = {
                onInitializationComplete: () => {
                    // Unity Ads ready
                },
                onInitializationFailed: (error, message) => {
                    console.error('Unity Ads initialization failed');
                },
            };
            
            window.unityAds.initialize(unityGameID, isTestMode, sdkListener);
            
        } catch (error) {
            console.error('Error initializing Unity Ads:', error);
        }
    };
    
    // Function to show rewarded video ad
    const showRewardedVideo = () => {
        if (!rewardedPlacementID) {
            showToast('Ads are not available at the moment. Please try again later.');
            return;
        }
        
        if (typeof window.unityAds === 'undefined') {
            showToast('Ads are not ready yet. Please wait a moment and try again.');
            return;
        }
        
        const placementListener = {
            onPlacementContentReady: (placementId) => {
                // Show the ad now that it's ready
                window.unityAds.show(rewardedPlacementID);
            },
            onPlacementContentStateChange: (placementId, state) => {
                if (state === 'SHOW_STATE_COMPLETED') {
                    // Grant coins to user
                    grantAdReward();
                }
            },
            onShowFailed: (placementId, error, message) => {
                showToast('Failed to load ad. Please try again later.');
            },
        };
        
        // Store listener globally for mock access
        window.currentAdListener = placementListener;
        
        // Call the function to load the ad content
        window.unityAds.load(rewardedPlacementID, placementListener);
    };
    
    // Function to grant reward after watching ad
    let isRewardProcessing = false;
    const grantAdReward = async () => {
        if (isRewardProcessing) {
            return;
        }
        isRewardProcessing = true;
        
        try {
            const response = await fetch('/api/watch-ad-reward', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
            });
            
            const result = await response.json();
            
            if (result.success) {
                showToast(`üéâ You earned ${result.coinsEarned} coins!`);
                // Update balance display if on marketplace page
                if (document.getElementById('current-balance') && window.loadUserBalance) {
                    window.loadUserBalance();
                }
            } else {
                showToast('Failed to grant reward. Please try again.');
            }
        } catch (error) {
            console.error('Error granting ad reward:', error);
            showToast('Failed to grant reward. Please try again.');
        } finally {
            isRewardProcessing = false;
        }
    };
    
    // Set up watch ad button event listener
    const watchAdButton = document.getElementById('btn-watch-ad');
    if (watchAdButton) {
        // Remove any existing event listeners first
        watchAdButton.replaceWith(watchAdButton.cloneNode(true));
        const newWatchAdButton = document.getElementById('btn-watch-ad');
        newWatchAdButton.addEventListener('click', function() {
            showRewardedVideo();
        });
    }
    
    // Initialize Unity Ads when page loads
    initializeUnityAds();

});

</script>
</body>
</html>

