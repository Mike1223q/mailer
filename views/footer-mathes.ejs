<script>

document.addEventListener('DOMContentLoaded', async () => {
    // --- SHARED FUNCTION ---
    // This function can be used on any page that includes this script.
    
    // Function to show/hide profile banner and manage background
    const toggleProfileBanner = (show) => {
        const banner = document.getElementById('complete-profile-banner');
        if (banner) {
            if (show) {
                banner.classList.remove('d-none');
                document.body.style.background = '#000';
                document.body.style.overflow = 'hidden';
            } else {
                banner.classList.add('d-none');
                document.body.style.background = '';
                document.body.style.overflow = '';
            }
        }
    };

    const showToast = (message) => {
        const toast = document.createElement('div');
        toast.className = 'toast-notification';
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('show');
        }, 100);

        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove());
        }, 3000);
    };


    // --- PAGE DETECTION & LOGIC ---

    // 1. Check if we are on the PROFILE BROWSER page
    if (document.getElementById('card-container')) {
        const mainContent = document.getElementById('main-content');
        const banner = document.getElementById('complete-profile-banner');
        const cardContainer = document.getElementById('card-container');
        let currentUser;

        try {
            const userResponse = await fetch('/api/user/status');
            if (!userResponse.ok) throw new Error('Could not fetch user status');
            currentUser = await userResponse.json();
            
            // --- NEW: Populate Sidebar User Info ---
            const sidebarAvatar = document.getElementById('sidebar-avatar');
            const sidebarName = document.getElementById('sidebar-name');
            if (sidebarAvatar && sidebarName) {
                sidebarAvatar.src = currentUser.avatar || 'https://placehold.co/60x60/FFFFFF/000000?text=User';
                sidebarName.textContent = currentUser.name || 'User';
                
                // Apply premium gradient to sidebar name if user has premium
                if (currentUser.premium) {
                    sidebarName.classList.add('premium-name-gradient');
                } else {
                    sidebarName.classList.remove('premium-name-gradient');
                }
            }
            
            // --- NEW: Update notification badge ---
            try {
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating notification badge:', error);
            }


            if (currentUser.completedProfile) {
                mainContent.classList.remove('d-none');
                toggleProfileBanner(false);
                
                const navBack = document.getElementById('nav-back');
                const navNext = document.getElementById('nav-next');
                
                let profiles = [];
                let currentUserIndex = 0;
                let profileCardElement = null;
                let timeLeftForNewMatches = ''; // Variable to store the time left

                const createCardElement = () => {
                    const existingCard = cardContainer.querySelector('.profile-card');
                    if (existingCard) {
                        profileCardElement = existingCard;
                    } else {
                        profileCardElement = document.createElement('div');
                        profileCardElement.className = 'profile-card';
                        cardContainer.prepend(profileCardElement);
                    }
                };
                
                const updateCardContent = (profile) => {
                    if (!profile) return;

                    console.log('Updating card content for profile:', profile);
                    console.log('Profile premium status:', profile.isPremium);

                    const interestsHTML = Array.isArray(profile.interests)
                        ? profile.interests.map(interest => `<span class="interest-tag">${interest}</span>`).join('')
                        : ''; 
                    
                    profileCardElement.innerHTML = `
                        <img src="${profile.avatar}" class="profile-card-image" alt="${profile.firstName}">
                        <div class="profile-card-body">
                            <div class="profile-card-bio">
                                <div class="profile-name-row">
                                    <h4 class="card-title fw-bold ${profile.isPremium ? 'premium-name-gradient' : ''}">${profile.firstName}</h4>
                                </div>
                                <p class="card-text text-white-50">${profile.bio}</p>
                            </div>
                            <div class="profile-card-interests">
                                ${interestsHTML}
                            </div>
                        </div>
                        <div class="profile-card-actions">
                            <button class="action-btn" data-user-id="${profile.id}" data-action="email">
                                <i class="fas fa-envelope"></i> Email
                            </button>
                            <button class="action-btn" data-user-id="${profile.id}" data-action="letter">
                                <i class="fas fa-paper-plane"></i> Letter
                            </button>
                        </div>
                    `;
                };

                const displayNewMatchCard = () => {
                    let cardContentHTML = '';
                    if (currentUser.premium) {
                        cardContentHTML = `
                            <h4>Find New Matches</h4>
                            <p>Your next batch of profiles will be ready in <strong>${timeLeftForNewMatches}</strong>.</p>
                            <button id="purchase-matches-btn">
                                <i class="fas fa-coins"></i> 100 Coins to Get One Now
                            </button>
                        `;
                    } else {
                        cardContentHTML = `
                            <h4>Out of Matches</h4>
                            <p>Your next free batch arrives in <strong>${timeLeftForNewMatches}</strong>. Get 100+ new matches every week with Premium, or get a new one now.</p>
                            <button id="purchase-matches-btn">
                                <i class="fas fa-coins"></i> 100 Coins
                            </button>
                            <a href="/subscribe" class="btn-premium-offer">Go Premium</a>
                        `;
                    }

                    cardContainer.innerHTML = `
                        <div class="profile-card new-match-card">
                            <div class="new-match-content">
                                <i class="fas fa-gift new-match-icon"></i>
                                ${cardContentHTML}
                            </div>
                        </div>
                    `;
                    cardContainer.append(navBack, navNext);
                    navBack.classList.remove('d-none');
                    navNext.classList.add('d-none');
                    document.getElementById('purchase-matches-btn').addEventListener('click', purchaseNewMatches);
                };

                const purchaseNewMatches = async (e) => {
                    const button = e.target.closest('button');
                    button.disabled = true;
                    button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Purchasing...';

                    try {
                        const response = await fetch('/api/purchase-matches', { method: 'POST' });
                        const data = await response.json();

                        if (response.ok) {
                            showToast('Success! Finding new matches for you.');
                            currentUserIndex = 0;
                            fetchProfiles();
                        } else {
                            showToast(data.error || 'Purchase failed.');
                            button.disabled = false;
                            button.innerHTML = '<i class="fas fa-coins"></i> 100 Coins';
                        }
                    } catch (error) {
                        showToast('An error occurred. Please try again.');
                        button.disabled = false;
                        button.innerHTML = '<i class="fas fa-coins"></i> 100 Coins';
                    }
                };

                const updateNavControls = () => {
                    // Hide the back button if we are on the first profile
                    if (currentUserIndex === 0) {
                        navBack.classList.add('d-none');
                    } else {
                        navBack.classList.remove('d-none');
                    }
                };

                const displayProfile = (index) => {
                    if (index >= profiles.length) {
                        displayNewMatchCard();
                        return;
                    }
                    
                    if (!profileCardElement || !cardContainer.contains(profileCardElement)) {
                         cardContainer.innerHTML = '';
                         createCardElement();
                         cardContainer.append(navBack, navNext);
                    }
                    
                    navBack.classList.remove('d-none');
                    navNext.classList.remove('d-none');
                    
                    profileCardElement.classList.add('changing');

                    setTimeout(() => {
                        const profile = profiles[index];
                        updateCardContent(profile);
                        profileCardElement.classList.remove('changing');
                    }, 200);

                    updateNavControls();
                };

                const fetchProfiles = async () => {
                    cardContainer.innerHTML = `<h5 class="text-center text-white-50">Loading profiles...</h5>`;

                    try {
                        const profilesResponse = await fetch('/api/profiles');
                        if (!profilesResponse.ok) throw new Error('Could not fetch profiles');
                        
                        const data = await profilesResponse.json();
                        profiles = data.profiles || data; // Handle both new and old format
                        timeLeftForNewMatches = data.timeLeft || 'Ready now';
                        
                        cardContainer.innerHTML = ''; 
                        
                        if (profiles && profiles.length > 0) {
                            createCardElement();
                            cardContainer.append(navBack, navNext);
                            navBack.classList.remove('d-none');
                            navNext.classList.remove('d-none');
                            updateCardContent(profiles[currentUserIndex]);
                            updateNavControls(); // Call here for the initial state
                        } else {
                            displayNewMatchCard();
                        }

                    } catch (error) {
                        console.error('Error fetching profiles:', error);
                        cardContainer.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
                    }
                };
                
                navNext.addEventListener('click', () => {
                    currentUserIndex++;
                    displayProfile(currentUserIndex);
                });

                navBack.addEventListener('click', () => {
                    if (currentUserIndex > 0) {
                        currentUserIndex--;
                        displayProfile(currentUserIndex);
                    }
                });
                
                cardContainer.addEventListener('click', (e) => {
                    const button = e.target.closest('.action-btn');
                    if (!button) return;
                    
                    const userId = button.dataset.userId;
                    const action = button.dataset.action;

                    if (action === 'email') {
                        const recipientName = profiles[currentUserIndex].firstName;
                        window.location.href = `/writing?action=email&name=${encodeURIComponent(recipientName)}&userId=${profiles[currentUserIndex].id}`;
                        return;
                    }

                    if (action === 'letter') {
                        const recipientName = profiles[currentUserIndex].firstName;
                        window.location.href = `/writing?action=letter&name=${encodeURIComponent(recipientName)}&userId=${profiles[currentUserIndex].id}`;
                        return;
                    }
                });

                fetchProfiles();

            } else {
                mainContent.classList.add('d-none');
                toggleProfileBanner(true);
            }
        } catch (error) {
            console.error('Initialization Error:', error);
            mainContent.innerHTML = `<div class="alert alert-danger">Error loading page: ${error.message}</div>`;
            toggleProfileBanner(false);
        }
    }

    // 2. Check if we are on the LETTER WRITING page
    if (document.getElementById('letter-body')) {
        let currentUser;
        let isSaved = false;
        let originalContent = '';
        
        const letterBody = document.getElementById('letter-body');
        const suggestions = document.querySelectorAll('.suggestion-btn');
        const cancelButton = document.querySelector('.btn-cancel');
        const sendButton = document.querySelector('.btn-send');
        const saveButton = document.querySelector('.btn-save');
        const safesendToggle = document.getElementById('safesend-toggle');

        // Load SafeSend preferences
        const loadSafeSendPreferences = async () => {
            try {
                const response = await fetch('/api/safesend-preferences');
                if (response.ok) {
                    const data = await response.json();
                    safesendToggle.checked = data.safesendEnabled;
                }
            } catch (error) {
                console.error('Error loading SafeSend preferences:', error);
            }
        };

        // Update SafeSend preferences
        const updateSafeSendPreferences = async (enabled) => {
            try {
                const response = await fetch('/api/update-safesend', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showToast(`SafeSend ${enabled ? 'enabled' : 'disabled'} successfully`);
                } else {
                    const errorData = await response.json();
                    showToast(errorData.error || 'Failed to update SafeSend preferences');
                    // Revert toggle if update failed
                    safesendToggle.checked = !enabled;
                }
            } catch (error) {
                console.error('Error updating SafeSend preferences:', error);
                showToast('Failed to update SafeSend preferences');
                // Revert toggle if update failed
                safesendToggle.checked = !enabled;
            }
        };

        // Load SafeSend preferences when page loads
        loadSafeSendPreferences();

        // Handle SafeSend toggle changes
        safesendToggle.addEventListener('change', (e) => {
            updateSafeSendPreferences(e.target.checked);
        });

        // Show SafeSend status indicator
        const showSafeSendStatus = (enabled) => {
            const description = document.querySelector('.safesend-description small');
            if (enabled) {
                description.innerHTML = 'Content safety filter enabled. <span style="color: var(--glow-color-1);">✓ Your messages will be filtered for safety.</span>';
            } else {
                description.innerHTML = 'Content safety filter disabled for you. <span style="color: var(--subtle-font-color);">⚠ Other users can still enforce SafeSend on messages sent to them.</span>';
            }
        };

        // Update status display when preferences change
        safesendToggle.addEventListener('change', (e) => {
            showSafeSendStatus(e.target.checked);
        });

        // Show initial status
        showSafeSendStatus(safesendToggle.checked);

        const urlParams = new URLSearchParams(window.location.search);
        const recipientName = urlParams.get('name') || 'User';
        const action = urlParams.get('action') || 'letter'; // Default to letter if not specified
        const recipientId = urlParams.get('userId');
        document.getElementById('recipient-name').textContent = recipientName;

        // Function to load draft
        const loadDraft = async () => {
            if (!recipientId) return;
            
            try {
                const response = await fetch(`/api/load-draft?recipientId=${recipientId}&action=${action}`);
                
                if (response.ok) {
                    const draftData = await response.json();
                    letterBody.value = draftData.content;
                    originalContent = draftData.content;
                    isSaved = true;
                    
                    // Update save button to show saved state
                    saveButton.textContent = 'Saved ';
                    saveButton.innerHTML = 'Saved <i class="fas fa-check"></i>';
                    saveButton.classList.add('saved');
                    
                    // Show notification about loaded draft
                    showToast(`Draft loaded from ${new Date(draftData.updatedAt).toLocaleDateString()}`);
                }
            } catch (error) {
                console.error('Error loading draft:', error);
                // Don't show error toast for draft loading - it's optional
            }
        };

        // Load draft when page loads
        loadDraft();

        // Update send button text based on action type
        const sendBtn = document.getElementById('send-btn');
        if (sendBtn) {
            if (action === 'email') {
                sendBtn.textContent = 'Send Email ';
                sendBtn.innerHTML = 'Send Email <i class="fas fa-envelope"></i>';
            } else {
                sendBtn.textContent = 'Send Letter ';
                sendBtn.innerHTML = 'Send Letter <i class="fas fa-paper-plane"></i>';
            }
        }

        // Update sidebar with user information
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    const sidebarPremiumBadge = document.getElementById('sidebar-premium-badge');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || 'https://placehold.co/60x60/FFFFFF/000000?text=User';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                    if (sidebarPremiumBadge) {
                        if (userData.premium) {
                            sidebarPremiumBadge.classList.remove('d-none');
                        } else {
                            sidebarPremiumBadge.classList.add('d-none');
                        }
                    }
                }
                
                // Update notification badge
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Update sidebar when page loads
        updateSidebar();

        // Check if profile is complete for writing page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on writing page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }

        // Function to check if content has changed
        const checkContentChange = () => {
            if (isSaved && letterBody.value !== originalContent) {
                isSaved = false;
                saveButton.textContent = 'Save ';
                saveButton.innerHTML = 'Save <i class="fas fa-save"></i>';
                saveButton.classList.remove('saved');
            }
        };

        // Listen for text changes
        letterBody.addEventListener('input', checkContentChange);
        letterBody.addEventListener('paste', checkContentChange);
        letterBody.addEventListener('keydown', checkContentChange);

        suggestions.forEach(button => {
            button.addEventListener('click', () => {
                const suggestionText = button.textContent;
                if (letterBody.value.trim() === '') {
                    letterBody.value = suggestionText;
                } else {
                    letterBody.value += ` ${suggestionText}`;
                }
                letterBody.focus();
                checkContentChange(); // Check for changes after adding suggestion
            });
        });

        cancelButton.addEventListener('click', (e) => {
            e.preventDefault();
            window.history.back();
        });

        // Save button functionality
        saveButton.addEventListener('click', async () => {
            if (letterBody.value.trim() === '') {
                showToast('Cannot save empty content.');
                return;
            }

            try {
                saveButton.disabled = true;
                saveButton.textContent = 'Saving...';
                
                const saveData = {
                    content: letterBody.value,
                    recipientId: urlParams.get('userId'),
                    recipientName: recipientName,
                    action: action
                };

                const response = await fetch('/api/save-draft', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(saveData)
                });

                if (response.ok) {
                    isSaved = true;
                    originalContent = letterBody.value;
                    saveButton.textContent = 'Saved ';
                    saveButton.innerHTML = 'Saved <i class="fas fa-check"></i>';
                    saveButton.classList.add('saved');
                    showToast('Draft saved successfully!');
                } else {
                    const errorData = await response.json();
                    showToast(errorData.error || 'Failed to save draft.');
                }
            } catch (error) {
                console.error('Save error:', error);
                showToast('Failed to save draft. Please try again.');
            } finally {
                saveButton.disabled = false;
            }
        });

        try {
            const userResponse = await fetch('/api/user/status');
            if (!userResponse.ok) throw new Error('Could not fetch user status');
            currentUser = await userResponse.json();

            // Only check letter credits if the action is 'letter'
            if (action === 'letter' && !currentUser.letterCredits) {
                sendButton.style.backgroundColor = '#555';
                sendButton.style.boxShadow = 'none';
                sendButton.style.opacity = '0.7';
            }

            sendButton.addEventListener('click', async () => {
                // Only check letter credits if the action is 'letter'
                if (action === 'letter' && !currentUser.letterCredits) {
                    showToast('You do not have enough credits to send a letter.');
                    return;
                }
                
                if (letterBody.value.trim() === '') {
                    showToast('Your message cannot be empty.');
                    return;
                }

                try {
                    sendButton.disabled = true;
                    sendButton.textContent = 'Sending...';
                    
                    const sendData = {
                        content: letterBody.value,
                        recipientId: recipientId,
                        messageType: action
                    };

                    const response = await fetch('/api/send-message', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(sendData)
                    });

                    const data = await response.json();

                    if (response.ok) {
                        const messageType = action === 'email' ? 'Email' : 'Letter';
                        showToast(`${messageType} sent successfully!`);
                        
                        // Redirect to chats page
                        setTimeout(() => {
                            window.location.href = `/chats?id=${recipientId}`;
                        }, 1500);
                    } else {
                        if (response.status === 402) {
                            showToast('Insufficient letter credits. Please purchase more credits.');
                        } else if (data.safesendBlocked) {
                            showToast('SafeSend blocked your message due to inappropriate content. Even if you disabled SafeSend, the recipient has it enabled, so all messages sent to them are filtered for safety.');
                        } else {
                            showToast(data.error || 'Failed to send message.');
                        }
                    }
                } catch (error) {
                    console.error('Send error:', error);
                    showToast('Failed to send message. Please try again.');
                } finally {
                    sendButton.disabled = false;
                    sendButton.textContent = action === 'email' ? 'Send Email' : 'Send Letter';
                    sendButton.innerHTML = action === 'email' ? 'Send Email <i class="fas fa-envelope"></i>' : 'Send Letter <i class="fas fa-paper-plane"></i>';
                }
            });

        } catch (error) {
            console.error('Initialization Error:', error);
            sendButton.disabled = true;
            sendButton.style.opacity = '0.5';
            sendButton.style.cursor = 'not-allowed';
            showToast('Could not verify credits. Sending is disabled.');
        }
    }

    // 3. Check if we are on the CHATS page
    if (document.getElementById('chats-list')) {
        let allChats = [];
        let filteredChats = [];
        
        const chatsList = document.getElementById('chats-list');
        const noChats = document.getElementById('no-chats');
        const searchInput = document.getElementById('search-chats');

        // Function to format timestamp
        const formatTime = (timestamp) => {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else if (diffDays === 1) {
                return 'Yesterday';
            } else if (diffDays < 7) {
                return date.toLocaleDateString([], { weekday: 'short' });
            } else {
                return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            }
        };

        // Function to truncate message
        const truncateMessage = (message, maxLength = 60) => {
            // Remove HTML tags and markdown formatting for preview
            let cleanMessage = message
                .replace(/<[^>]*>/g, '') // Remove HTML tags
                .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold formatting
                .replace(/\*(.*?)\*/g, '$1') // Remove italic formatting
                .replace(/\n/g, ' '); // Replace newlines with spaces
            
            // Special handling for delivery messages
            if (cleanMessage.includes('will be delivered in') || cleanMessage.includes('will be shipped within')) {
                cleanMessage = cleanMessage.replace(/will be delivered in \d+ hours!.*/, 'will be delivered soon...');
                cleanMessage = cleanMessage.replace(/will be shipped within.*/, 'will be shipped soon...');
            }
            
            if (cleanMessage.length <= maxLength) return cleanMessage;
            return cleanMessage.substring(0, maxLength) + '...';
        };

        // Function to create chat item HTML
        const createChatItem = (chat, unreadCounts = {}) => {
            const lastMessage = chat.messages[chat.messages.length - 1];
            // Get current user ID from the page or use a fallback
            const currentUserId = window.currentUserId || null;
            const isOutgoing = currentUserId && lastMessage.senderId == currentUserId;
            const unreadCount = unreadCounts[chat.userId] ? unreadCounts[chat.userId].total : 0;
            
            return `
                <div class="chat-item ${unreadCount > 0 ? 'has-unread' : ''}" data-user-id="${chat.userId}">
                    <div class="chat-item-header">
                        <img src="${chat.avatar || 'https://placehold.co/50x50/FFFFFF/000000?text=U'}" 
                             alt="${chat.name}" class="chat-avatar">
                        <div class="chat-info">
                            <div class="chat-name">${chat.name}</div>
                            <div class="chat-last-message">
                                ${isOutgoing ? 'You: ' : ''}${truncateMessage(lastMessage.content)}
                            </div>
                        </div>
                        <div class="chat-meta">
                            <div class="chat-time">${formatTime(lastMessage.timestamp)}</div>
                            <div class="chat-badges">
                                <div class="chat-type-badge badge-${lastMessage.messageType}">
                                    ${lastMessage.messageType}
                                </div>
                                ${unreadCount > 0 ? `<div class="chat-unread-badge">${unreadCount}</div>` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        };

        // Function to render chats
        const renderChats = async (chats) => {
            if (chats.length === 0) {
                chatsList.style.display = 'none';
                noChats.style.display = 'block';
                return;
            }

            chatsList.style.display = 'block';
            noChats.style.display = 'none';
            
            // Fetch unread counts
            let unreadCounts = {};
            try {
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    unreadCounts = unreadData.unreadBySender || {};
                }
            } catch (error) {
                console.error('Error fetching unread counts:', error);
            }
            
            chatsList.innerHTML = chats.map(chat => createChatItem(chat, unreadCounts)).join('');
            
            // Add click handlers
            document.querySelectorAll('.chat-item').forEach(item => {
                item.addEventListener('click', async () => {
                    const userId = item.dataset.userId;
                    
                    // Mark messages as read before navigating
                    try {
                        await fetch(`/api/mark-as-read/${userId}`, {
                            method: 'POST'
                        });
                        
                        // Update sidebar notification badge
                        updateSidebar();
                    } catch (error) {
                        console.error('Error marking messages as read:', error);
                    }
                    
                    window.location.href = `/chat-view?id=${userId}`;
                });
            });
        };

        // Function to filter chats
        const filterChats = async (searchTerm) => {
            if (!searchTerm.trim()) {
                filteredChats = allChats;
            } else {
                filteredChats = allChats.filter(chat => 
                    chat.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    chat.messages.some(msg => 
                        msg.content.toLowerCase().includes(searchTerm.toLowerCase())
                    )
                );
            }
            await renderChats(filteredChats);
        };

        // Search functionality
        searchInput.addEventListener('input', async (e) => {
            await filterChats(e.target.value);
        });

        // Refresh button functionality
        const refreshButton = document.getElementById('btn-refresh-chats');
        if (refreshButton) {
            refreshButton.addEventListener('click', () => {
                refreshButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                refreshButton.disabled = true;
                
                loadChats().finally(() => {
                    refreshButton.innerHTML = '<i class="fas fa-sync-alt"></i>';
                    refreshButton.disabled = false;
                });
            });
        }

                // Load chats
        const loadChats = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (!userResponse.ok) throw new Error('Could not fetch user status');
                const currentUser = await userResponse.json();
                
                // Set current user ID globally for use in other functions
                window.currentUserId = currentUser.id;

                const chatHistoryResponse = await fetch('/api/chat-history');
                if (!chatHistoryResponse.ok) throw new Error('Could not fetch chat history');
                const chatHistory = await chatHistoryResponse.json();

                console.log('Chat history response:', chatHistory); // Debug log

                // Process chat history into chat list
                const chatHistoryData = chatHistory.chatHistory || {};
                const chats = [];

                console.log('Chat history data:', chatHistoryData); // Debug log

                for (const [userId, messages] of Object.entries(chatHistoryData)) {
                    console.log(`Processing user ${userId} with ${messages.length} messages`); // Debug log
                    
                    if (messages && messages.length > 0) {
                        try {
                            // Get user info for this chat
                            const userInfoResponse = await fetch(`/api/user-info/${userId}`);
                            if (userInfoResponse.ok) {
                                const userInfo = await userInfoResponse.json();
                                chats.push({
                                    userId: userId,
                                    name: userInfo.firstName || 'Unknown User',
                                    avatar: userInfo.avatar,
                                    messages: messages
                                });
                            } else {
                                console.log(`Failed to get user info for ${userId}`); // Debug log
                            }
                        } catch (userError) {
                            console.error(`Error getting user info for ${userId}:`, userError);
                        }
                    }
                }

                console.log('Processed chats:', chats); // Debug log

                // Sort by most recent message
                chats.sort((a, b) => {
                    const aTime = new Date(a.messages[a.messages.length - 1].timestamp);
                    const bTime = new Date(b.messages[b.messages.length - 1].timestamp);
                    return bTime - aTime;
                });

                allChats = chats;
                filteredChats = chats;
                await renderChats(chats);

            } catch (error) {
                console.error('Error loading chats:', error);
                chatsList.innerHTML = '<div class="error-message">Failed to load conversations. Please try again.</div>';
            }
        };

        // Update sidebar
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    const sidebarPremiumBadge = document.getElementById('sidebar-premium-badge');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || 'https://placehold.co/60x60/FFFFFF/000000?text=User';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                    if (sidebarPremiumBadge) {
                        if (userData.premium) {
                            sidebarPremiumBadge.classList.remove('d-none');
                        } else {
                            sidebarPremiumBadge.classList.add('d-none');
                        }
                    }
                }
                
                // Update notification badge
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Initialize
        updateSidebar();
        loadChats();

        // Check if profile is complete for chats page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on chats page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }

        // Refresh chats when page becomes visible (user navigates back)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('Page became visible, refreshing chats...');
                loadChats();
            }
        });

        // Also refresh on page focus (when user clicks back to tab)
        window.addEventListener('focus', () => {
            console.log('Window focused, refreshing chats...');
            loadChats();
        });

        // Refresh when user navigates back to the page
        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                console.log('Page loaded from back-forward cache, refreshing chats...');
                loadChats();
            }
        });
    }

    // 4. Check if we are on the CHAT VIEW page
    if (document.getElementById('messages-container')) {
        let currentUserId = null;
        let otherUserId = null;
        let otherUserName = '';
        let otherUserAvatar = '';
        
        const messagesContainer = document.getElementById('messages-container');
        const writeEmailButton = document.getElementById('btn-write-email');
        const writeLetterButton = document.getElementById('btn-write-letter');
        const chatUserName = document.getElementById('chat-user-name');
        const chatUserAvatar = document.getElementById('chat-user-avatar');

        // Function to format timestamp
        const formatMessageTime = (timestamp) => {
            const date = new Date(timestamp);
            const now = new Date();
            const diffInHours = (now - date) / (1000 * 60 * 60);
            
            // If message is from today, show time only
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
            // If message is from yesterday, show "Yesterday" and time
            else if (diffInHours < 48 && date.toDateString() === new Date(now.getTime() - 24 * 60 * 60 * 1000).toDateString()) {
                return `Yesterday ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
            }
            // Otherwise show full month name and day, plus time
            else {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                const monthName = monthNames[date.getMonth()];
                const day = date.getDate();
                const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                return `${monthName} ${day} ${time}`;
            }
        };

        // Function to create message HTML
        const createMessageHTML = (message, isOutgoing) => {
            const messageClass = isOutgoing ? 'outgoing' : 'incoming';
            const messageTime = formatMessageTime(message.timestamp);
            
            // Format message content (handle basic markdown-like formatting)
            let formattedContent = message.content;
            if (message.messageType === 'letter' || message.messageType === 'email') {
                // Convert markdown-like formatting to HTML
                formattedContent = message.content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br>');
            }
            
            return `
                <div class="message ${messageClass} ${message.messageType === 'letter' ? 'letter-message' : ''} ${message.messageType === 'email' ? 'email-message' : ''}">
                    <div class="message-content">
                        <div class="message-text">${formattedContent}</div>
                        <div class="message-meta">
                            <span class="message-time">${messageTime}</span>
                            <span class="message-type-badge badge-${message.messageType}">${message.messageType}</span>
                        </div>
                    </div>
                </div>
            `;
        };

        // Function to render messages
        const renderMessages = (messages) => {
            if (messages.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="no-messages">
                        <div class="no-messages-icon">
                            <i class="fas fa-comments"></i>
                        </div>
                        <h3>No messages yet</h3>
                        <p>Start the conversation by sending a message!</p>
                    </div>
                `;
                return;
            }

            const messagesHTML = messages.map(message => {
                const isOutgoing = message.senderId == currentUserId;
                return createMessageHTML(message, isOutgoing);
            }).join('');

            messagesContainer.innerHTML = messagesHTML;
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        };



        // Function to load messages
        const loadMessages = async () => {
            try {
                const response = await fetch(`/api/chat-history/${otherUserId}`);
                if (response.ok) {
                    const data = await response.json();
                    renderMessages(data.conversation);
                } else {
                    messagesContainer.innerHTML = '<div class="error-message">Failed to load messages.</div>';
                }
            } catch (error) {
                console.error('Error loading messages:', error);
                messagesContainer.innerHTML = '<div class="error-message">Failed to load messages.</div>';
            }
        };

        // Function to load user info
        const loadUserInfo = async () => {
            try {
                const response = await fetch(`/api/user-info/${otherUserId}`);
                if (response.ok) {
                    const userInfo = await response.json();
                    otherUserName = userInfo.firstName || 'Unknown User';
                    otherUserAvatar = userInfo.avatar || 'https://placehold.co/50x50/FFFFFF/000000?text=U';
                    
                    // Update UI
                    chatUserName.textContent = otherUserName;
                    chatUserAvatar.src = otherUserAvatar;
                }
            } catch (error) {
                console.error('Error loading user info:', error);
            }
        };

        // Event listeners
        writeEmailButton.addEventListener('click', () => {
            const recipientName = encodeURIComponent(chatUserName.textContent);
            window.location.href = `/writing?action=email&userId=${otherUserId}&name=${recipientName}`;
        });

        writeLetterButton.addEventListener('click', () => {
            const recipientName = encodeURIComponent(chatUserName.textContent);
            window.location.href = `/writing?action=letter&userId=${otherUserId}&name=${recipientName}`;
        });

        // Initialize chat view
        const initializeChatView = async () => {
            const urlParams = new URLSearchParams(window.location.search);
            otherUserId = urlParams.get('id');
            
            if (!otherUserId) {
                messagesContainer.innerHTML = '<div class="error-message">No user ID provided.</div>';
                return;
            }

            // Get current user ID
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    currentUserId = userData.id;
                }
            } catch (error) {
                console.error('Error getting current user:', error);
            }

            // Load user info and messages
            await loadUserInfo();
            await loadMessages();
            
            // Mark messages from this user as read
            try {
                await fetch(`/api/mark-as-read/${otherUserId}`, {
                    method: 'POST'
                });
            } catch (error) {
                console.error('Error marking messages as read:', error);
            }
        };

        // Update sidebar
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || 'https://placehold.co/60x60/FFFFFF/000000?text=User';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Initialize
        updateSidebar();
        initializeChatView();

        // Check if profile is complete for chat view page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on chat view page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }
    }

    // 5. Check if we are on the MARKETPLACE page
    if (document.getElementById('current-balance')) {
        let currentUser = null;

        // Load user balance and update display
        const loadUserBalance = async () => {
            try {
                const response = await fetch('/api/user/status');
                if (response.ok) {
                    currentUser = await response.json();
                    
                    // Update coins balance
                    const balanceElement = document.getElementById('current-balance');
                    if (balanceElement) {
                        balanceElement.textContent = `${currentUser.coins || 0} Coins`;
                    }
                    
                    // Update letter credits balance
                    const letterCreditsElement = document.getElementById('current-letter-credits');
                    if (letterCreditsElement) {
                        letterCreditsElement.textContent = `${currentUser.letterCredits || 0} Letter Credits`;
                    }
                }
            } catch (error) {
                console.error('Error loading user balance:', error);
            }
        };

        // Watch ad functionality
        const watchAdButton = document.getElementById('btn-watch-ad');
        if (watchAdButton) {
            watchAdButton.addEventListener('click', async () => {
                watchAdButton.disabled = true;
                watchAdButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Watching...';
                
                try {
                    // Simulate ad watching (in real app, this would integrate with ad service)
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    // Add coins to user account
                    const response = await fetch('/api/watch-ad', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        showToast('🎉 You earned 100 coins!');
                        await loadUserBalance(); // Refresh balance
                    } else {
                        showToast('Failed to earn coins. Please try again.');
                    }
                } catch (error) {
                    console.error('Error watching ad:', error);
                    showToast('Error watching ad. Please try again.');
                } finally {
                    watchAdButton.disabled = false;
                    watchAdButton.innerHTML = '<i class="fas fa-play"></i> Watch Ad';
                }
            });
        }

        // Buy package functionality
        document.querySelectorAll('.btn-buy-package').forEach(button => {
            button.addEventListener('click', async () => {
                const packageType = button.dataset.package;
                const amount = parseInt(button.dataset.amount);
                const price = parseFloat(button.dataset.price);
                const isCredits = button.dataset.credits === 'true';
                
                const itemName = isCredits ? 'letter credits' : 'coins';
                const itemText = isCredits ? `${amount} letter credits` : `${amount} coins`;
                
                if (confirm(`Purchase ${itemText} for $${price}?`)) {
                    button.disabled = true;
                    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                    
                    try {
                        // In real app, this would integrate with payment processor
                        showToast(`💳 Processing payment for ${itemText}...`);
                        
                        // Simulate payment processing
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        if (isCredits) {
                            // Purchase letter credits
                            const response = await fetch('/api/buy-letter-credits', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ package: packageType, amount, price })
                            });
                            
                            if (response.ok) {
                                showToast(`🎉 Successfully purchased ${amount} letter credits!`);
                            } else {
                                showToast('Payment failed. Please try again.');
                            }
                        } else {
                            // Add coins to user account
                            const response = await fetch('/api/buy-coins', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ package: packageType, amount, price })
                            });
                            
                            if (response.ok) {
                                showToast(`🎉 Successfully purchased ${amount} coins!`);
                                await loadUserBalance(); // Refresh balance
                            } else {
                                showToast('Payment failed. Please try again.');
                            }
                        }
                    } catch (error) {
                        console.error('Error buying package:', error);
                        showToast('Error processing payment. Please try again.');
                    } finally {
                        button.disabled = false;
                        button.innerHTML = '<i class="fas fa-shopping-cart"></i> Buy Now';
                    }
                }
            });
        });

        // Premium option selection
        const premiumOptions = document.querySelectorAll('.premium-option');
        const becomePremiumButton = document.getElementById('btn-become-premium');
        
        premiumOptions.forEach(option => {
            option.addEventListener('click', () => {
                // Remove selected class from all options
                premiumOptions.forEach(opt => opt.classList.remove('selected'));
                // Add selected class to clicked option
                option.classList.add('selected');
                
                // Update button text and data
                const plan = option.dataset.plan;
                const price = option.querySelector('.option-price').textContent;
                const period = option.querySelector('.option-period').textContent;
                
                becomePremiumButton.dataset.plan = plan;
                becomePremiumButton.innerHTML = `<i class="fas fa-crown"></i> Get Premium ${period.charAt(0).toUpperCase() + period.slice(1)}`;
            });
        });

        // Become premium functionality
        if (becomePremiumButton) {
            becomePremiumButton.addEventListener('click', async () => {
                const selectedPlan = document.querySelector('.premium-option.selected');
                const plan = selectedPlan.dataset.plan;
                const price = selectedPlan.querySelector('.option-price').textContent;
                const period = selectedPlan.querySelector('.option-period').textContent;
                
                if (confirm(`Upgrade to Premium ${period} for ${price}?`)) {
                    becomePremiumButton.disabled = true;
                    becomePremiumButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                    
                    try {
                        // In real app, this would integrate with subscription service
                        showToast(`🚀 Processing premium upgrade for ${period}...`);
                        
                        // Simulate subscription processing
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        // Upgrade user to premium
                        const response = await fetch('/api/upgrade-premium', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ plan, price, period })
                        });
                        
                        if (response.ok) {
                            showToast('🎉 Welcome to Premium! Enjoy exclusive features!');
                            // Update letter credits pricing for premium users
                            updateLetterCreditsPricing(true);
                            // Refresh premium content
                            checkPremiumStatus();
                        } else {
                            showToast('Upgrade failed. Please try again.');
                        }
                    } catch (error) {
                        console.error('Error upgrading to premium:', error);
                        showToast('Error processing upgrade. Please try again.');
                    } finally {
                        becomePremiumButton.disabled = false;
                        const period = selectedPlan.querySelector('.option-period').textContent;
                        becomePremiumButton.innerHTML = `<i class="fas fa-crown"></i> Get Premium ${period.charAt(0).toUpperCase() + period.slice(1)}`;
                    }
                }
            });
        }

        // Update letter credits pricing based on premium status
        const updateLetterCreditsPricing = (isPremium) => {
            const letterCreditsPrice = document.getElementById('letter-credits-price');
            const discountBadge = document.getElementById('premium-discount-badge');
            const letterCreditsButton = document.querySelector('[data-package="letter-credits"]');
            
            if (isPremium) {
                // Show discounted price for premium users
                letterCreditsPrice.innerHTML = '<span style="text-decoration: line-through; opacity: 0.7; margin-right: 0.5rem;">$2.99</span><span style="color: #28a745; font-weight: 700;">$2.39</span>';
                discountBadge.style.display = 'block';
                // Update button data for premium price
                letterCreditsButton.dataset.price = '2.39';
                letterCreditsButton.dataset.amount = '1';
            } else {
                // Show only original price for non-premium users
                letterCreditsPrice.textContent = '$2.99';
                discountBadge.style.display = 'none';
                // Update button data for original price
                letterCreditsButton.dataset.price = '2.99';
                letterCreditsButton.dataset.amount = '1';
            }
        };

        // Check premium status and update pricing
        const checkPremiumStatus = async () => {
            try {
                const response = await fetch('/api/user/status');
                if (response.ok) {
                    const userData = await response.json();
                    updateLetterCreditsPricing(userData.premium || false);
                    updatePremiumContent(userData.premium || false);
                }
            } catch (error) {
                console.error('Error checking premium status:', error);
            }
        };

        // Update premium content based on status
        const updatePremiumContent = (isPremium) => {
            const nonPremiumContent = document.getElementById('non-premium-content');
            const premiumContent = document.getElementById('premium-content');
            
            if (isPremium) {
                nonPremiumContent.style.display = 'none';
                premiumContent.style.display = 'block';
                loadSubscriptionDetails();
            } else {
                nonPremiumContent.style.display = 'block';
                premiumContent.style.display = 'none';
            }
        };

        // Load subscription details
        const loadSubscriptionDetails = async () => {
            try {
                const response = await fetch('/api/subscription-details');
                if (response.ok) {
                    const subscription = await response.json();
                    if (subscription.premium) {
                        updateSubscriptionDisplay(subscription);
                    } else {
                        // If not premium, show non-premium content
                        updatePremiumContent(false);
                    }
                }
            } catch (error) {
                console.error('Error loading subscription details:', error);
                // On error, show non-premium content
                updatePremiumContent(false);
            }
        };

        // Update subscription display
        const updateSubscriptionDisplay = (subscription) => {
            const planType = document.getElementById('current-plan-type');
            const planDates = document.getElementById('current-plan-dates');
            
            if (planType && planDates) {
                const planNames = {
                    'monthly': 'Monthly Plan',
                    'half-year': '6-Month Plan',
                    'yearly': 'Yearly Plan'
                };
                
                let planText = planNames[subscription.type] || 'Premium Plan';
                if (subscription.cancelled) {
                    planText += ' (Cancelled)';
                }
                planType.textContent = planText;
                
                if (subscription.endDate) {
                    // Use the endDate from the backend (more accurate)
                    const nextBillingDate = new Date(subscription.endDate);
                    const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                    if (subscription.cancelled) {
                        planDates.textContent = `Access until: ${fullDate}`;
                    } else {
                        planDates.textContent = `Next billing: ${fullDate}`;
                    }
                } else if (subscription.startDate && subscription.type) {
                    // Fallback calculation if endDate is not available
                    const startDate = new Date(subscription.startDate);
                    let nextBillingDate;
                    
                    switch (subscription.type) {
                        case 'monthly':
                            nextBillingDate = new Date(startDate.getTime() + (30 * 24 * 60 * 60 * 1000));
                            break;
                        case 'half-year':
                            nextBillingDate = new Date(startDate.getTime() + (6 * 30 * 24 * 60 * 60 * 1000));
                            break;
                        case 'yearly':
                            nextBillingDate = new Date(startDate.getTime() + (365 * 24 * 60 * 60 * 1000));
                            break;
                        default:
                            nextBillingDate = startDate;
                    }
                    
                    const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                    if (subscription.cancelled) {
                        planDates.textContent = `Access until: ${fullDate}`;
                    } else {
                        planDates.textContent = `Next billing: ${fullDate}`;
                    }
                } else {
                    planDates.textContent = 'Next billing: Ongoing';
                }
            }
        };

        // Update sidebar
        const updateSidebar = async () => {
            try {
                const userResponse = await fetch('/api/user/status');
                if (userResponse.ok) {
                    const userData = await userResponse.json();
                    const sidebarAvatar = document.getElementById('sidebar-avatar');
                    const sidebarName = document.getElementById('sidebar-name');
                    
                    if (sidebarAvatar) {
                        sidebarAvatar.src = userData.avatar || 'https://placehold.co/60x60/FFFFFF/000000?text=User';
                    }
                    if (sidebarName) {
                        sidebarName.textContent = userData.name || 'User';
                        
                        // Apply premium gradient to sidebar name if user has premium
                        if (userData.premium) {
                            sidebarName.classList.add('premium-name-gradient');
                        } else {
                            sidebarName.classList.remove('premium-name-gradient');
                        }
                    }
                }
                
                // Update notification badge
                const unreadResponse = await fetch('/api/unread-counts');
                if (unreadResponse.ok) {
                    const unreadData = await unreadResponse.json();
                    const notificationBadge = document.getElementById('sidebar-notification-badge');
                    
                    if (notificationBadge) {
                        if (unreadData.hasUnread && unreadData.unreadByType.total > 0) {
                            notificationBadge.textContent = unreadData.unreadByType.total;
                            notificationBadge.classList.remove('d-none');
                        } else {
                            notificationBadge.classList.add('d-none');
                        }
                    }
                }
            } catch (error) {
                console.error('Error updating sidebar:', error);
            }
        };

        // Initialize marketplace page
        updateSidebar();
        loadUserBalance();
        checkPremiumStatus();

        // Subscription management
        const subscriptionModal = document.getElementById('subscription-modal');
        const manageSubscriptionBtn = document.getElementById('btn-manage-subscription');
        const closeModalBtn = document.getElementById('btn-close-modal');
        const cancelSubscriptionBtn = document.getElementById('btn-cancel-subscription');

        // Open subscription management modal
        if (manageSubscriptionBtn) {
            manageSubscriptionBtn.addEventListener('click', async () => {
                try {
                    const response = await fetch('/api/subscription-details');
                    if (response.ok) {
                        const subscription = await response.json();
                        if (subscription.premium) {
                            openSubscriptionModal(subscription);
                        }
                    }
                } catch (error) {
                    console.error('Error opening subscription modal:', error);
                }
            });
        }

        // Close modal
        if (closeModalBtn) {
            closeModalBtn.addEventListener('click', () => {
                subscriptionModal.style.display = 'none';
            });
        }

        // Close modal when clicking outside
        if (subscriptionModal) {
            subscriptionModal.addEventListener('click', (e) => {
                if (e.target === subscriptionModal) {
                    subscriptionModal.style.display = 'none';
                }
            });
        }

        // Open subscription modal with details
        const openSubscriptionModal = (subscription) => {
            const modalCurrentPlan = document.getElementById('modal-current-plan');
            const modalNextBilling = document.getElementById('modal-next-billing');
            const upgradeButtons = document.getElementById('upgrade-buttons');

            // Update modal content
            const planNames = {
                'monthly': 'Monthly Plan',
                'half-year': '6-Month Plan',
                'yearly': 'Yearly Plan'
            };

            let planText = planNames[subscription.type] || 'Premium Plan';
            if (subscription.cancelled) {
                planText += ' (Cancelled)';
            }
            modalCurrentPlan.textContent = planText;
            
            if (subscription.endDate) {
                // Use the endDate from the backend (more accurate)
                const nextBillingDate = new Date(subscription.endDate);
                const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                if (subscription.cancelled) {
                    modalNextBilling.textContent = `Access until: ${fullDate}`;
                } else {
                    modalNextBilling.textContent = `Next billing: ${fullDate}`;
                }
            } else if (subscription.startDate) {
                // Fallback calculation if endDate is not available
                const startDate = new Date(subscription.startDate);
                let nextBillingDate;
                
                switch (subscription.type) {
                    case 'monthly':
                        nextBillingDate = new Date(startDate.getTime() + (30 * 24 * 60 * 60 * 1000));
                        break;
                    case 'half-year':
                        nextBillingDate = new Date(startDate.getTime() + (6 * 30 * 24 * 60 * 60 * 1000));
                        break;
                    case 'yearly':
                        nextBillingDate = new Date(startDate.getTime() + (365 * 24 * 60 * 60 * 1000));
                        break;
                    default:
                        nextBillingDate = startDate;
                }
                
                const fullDate = nextBillingDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                if (subscription.cancelled) {
                    modalNextBilling.textContent = `Access until: ${fullDate}`;
                } else {
                    modalNextBilling.textContent = `Next billing: ${fullDate}`;
                }
            } else {
                modalNextBilling.textContent = 'Ongoing';
            }

            // Generate upgrade options based on current plan (only upgrades allowed)
            upgradeButtons.innerHTML = '';
            const currentPlan = subscription.type;
            
            if (subscription.cancelled) {
                // Show message for cancelled subscriptions
                const endDate = new Date(subscription.endDate);
                const fullDate = endDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                upgradeButtons.innerHTML = `
                    <p class="no-upgrade-message">Your subscription is cancelled. Premium features will remain active until ${fullDate}.</p>
                `;
            } else if (currentPlan === 'monthly') {
                upgradeButtons.innerHTML = `
                    <button class="upgrade-option-btn" data-plan="half-year">Upgrade to 6-Month ($29.99)</button>
                    <button class="upgrade-option-btn" data-plan="yearly">Upgrade to Yearly ($39.99)</button>
                `;
            } else if (currentPlan === 'half-year') {
                upgradeButtons.innerHTML = `
                    <button class="upgrade-option-btn" data-plan="yearly">Upgrade to Yearly ($39.99)</button>
                `;
            } else if (currentPlan === 'yearly') {
                upgradeButtons.innerHTML = `
                    <p class="no-upgrade-message">You're already on the highest plan!</p>
                `;
            }

            // Add event listeners to upgrade buttons
            document.querySelectorAll('.upgrade-option-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const newPlan = btn.dataset.plan;
                    if (confirm(`Are you sure you want to change to ${newPlan} plan?`)) {
                        try {
                            const response = await fetch('/api/upgrade-subscription', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ newPlan })
                            });

                            if (response.ok) {
                                showToast('Subscription updated successfully!');
                                subscriptionModal.style.display = 'none';
                                checkPremiumStatus(); // Refresh the display
                            } else {
                                const errorData = await response.json();
                                if (errorData.error && errorData.error.includes('Downgrades are not allowed')) {
                                    showToast('Downgrades are not allowed. You can only upgrade to a longer plan.');
                                } else {
                                    showToast('Failed to update subscription. Please try again.');
                                }
                            }
                        } catch (error) {
                            console.error('Error updating subscription:', error);
                            showToast('Error updating subscription. Please try again.');
                        }
                    }
                });
            });

            subscriptionModal.style.display = 'flex';
        };

        // Cancel subscription
        if (cancelSubscriptionBtn) {
            cancelSubscriptionBtn.addEventListener('click', async () => {
                if (confirm('Are you sure you want to cancel your premium subscription? Your premium features will remain active until the end of your current billing period.')) {
                    try {
                        const response = await fetch('/api/cancel-subscription', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const endDate = new Date(result.endDate);
                            showToast(`Subscription cancelled. Premium features will remain active until ${endDate.toLocaleDateString()}.`);
                            subscriptionModal.style.display = 'none';
                            checkPremiumStatus(); // Refresh the display
                        } else {
                            showToast('Failed to cancel subscription. Please try again.');
                        }
                    } catch (error) {
                        console.error('Error cancelling subscription:', error);
                        showToast('Error cancelling subscription. Please try again.');
                    }
                }
            });
        }

        // Check if profile is complete for marketplace page
        try {
            const userResponse = await fetch('/api/user/status');
            if (userResponse.ok) {
                const userData = await userResponse.json();
                if (!userData.completedProfile) {
                    // Show banner on marketplace page if profile incomplete
                    toggleProfileBanner(true);
                }
            }
        } catch (error) {
            console.error('Error checking profile status:', error);
        }
    }
});

</script>
</body>
</html>
